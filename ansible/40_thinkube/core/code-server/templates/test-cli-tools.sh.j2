#!/bin/bash
# Copyright 2025 Alejandro Martínez Corriá and the Thinkube contributors
# SPDX-License-Identifier: Apache-2.0

# Test script for all CLI tools configured in code-server
# Usage: /home/thinkube/test-cli-tools.sh [-v]
#   -v: Verbose mode - show all command output

set +e  # Don't exit on first error

# Parse command line arguments
VERBOSE=0
while getopts "v" opt; do
    case $opt in
        v)
            VERBOSE=1
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            echo "Usage: $0 [-v]"
            exit 1
            ;;
    esac
done

# Source environment configuration
[ -f ~/.thinkube_shared_shell/env_setup.sh ] && source ~/.thinkube_shared_shell/env_setup.sh
[ -f ~/.config/thinkube/service-env.sh ] && source ~/.config/thinkube/service-env.sh

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Track results
FAILED_TESTS=0
PASSED_TESTS=0

echo "======================================================================"
echo "  Thinkube CLI Tools Configuration Test"
echo "======================================================================"
echo ""

# Helper function to test a CLI tool
# Usage: test_cli "name" "config_check" "test_command" ["optional"]
#   - config_check: Command to check if service is configured (e.g., [ -n "$VAR" ])
#   - test_command: The actual test to run
#   - optional: If "optional", SKIP when not configured; otherwise FAIL
test_cli() {
    local name="$1"
    local config_check="$2"
    local test_command="$3"
    local is_optional="${4:-false}"

    echo -n "Testing ${name}... "

    # First check if service is configured
    if ! eval "$config_check" &>/dev/null; then
        # Service not configured
        if [ "$is_optional" = "optional" ]; then
            echo -e "${YELLOW}⊘ SKIP (service not configured)${NC}"
        else
            echo -e "${RED}❌ FAIL${NC} (required service not configured)"
            ((FAILED_TESTS++))
        fi
        return
    fi

    # Service IS configured, run the actual test
    if [ "$VERBOSE" = "1" ]; then
        # In verbose mode, show command output
        if eval "$test_command"; then
            echo -e "${GREEN}✅ PASS${NC}"
            ((PASSED_TESTS++))
        else
            echo -e "${RED}❌ FAIL${NC}"
            ((FAILED_TESTS++))
        fi
    else
        # In normal mode, suppress output
        if eval "$test_command" &>/dev/null; then
            echo -e "${GREEN}✅ PASS${NC}"
            ((PASSED_TESTS++))
        else
            echo -e "${RED}❌ FAIL${NC}"
            ((FAILED_TESTS++))
        fi
    fi
}

echo "=== Core CLI Tools ==="
echo ""

# Test kubectl
test_cli "kubectl" "true" "kubectl cluster-info"

# Test GitHub CLI
test_cli "GitHub CLI (gh)" "true" "gh auth status"

# Test ArgoCD CLI
test_cli "ArgoCD CLI" "true" "argocd version"

# Test Argo Workflows CLI (retry on failure due to intermittent connectivity)
echo -n "Testing Argo Workflows CLI... "
ARGO_TEST_PASSED=false
for attempt in 1 2 3; do
    if [ "$VERBOSE" = "1" ]; then
        if argo version; then
            ARGO_TEST_PASSED=true
            break
        fi
    else
        if argo version &>/dev/null; then
            ARGO_TEST_PASSED=true
            break
        fi
    fi
    [ $attempt -lt 3 ] && sleep 1
done

if [ "$ARGO_TEST_PASSED" = "true" ]; then
    echo -e "${GREEN}✅ PASS${NC}"
    ((PASSED_TESTS++))
else
    echo -e "${RED}❌ FAIL${NC}"
    ((FAILED_TESTS++))
fi

# Test Tea (Gitea CLI)
test_cli "Tea (Gitea CLI)" "true" "tea login list"

# Test Harbor registry configuration (used with podman)
test_cli "Harbor registry config" "true" "grep '{{ harbor_registry }}' ~/.docker/config.json"

# Test git configuration
echo -n "Testing git config... "
if git config --get user.name &>/dev/null && git config --get user.email &>/dev/null; then
    echo -e "${GREEN}✅ PASS${NC} (user: $(git config --get user.name))"
    ((PASSED_TESTS++))
else
    echo -e "${RED}❌ FAIL${NC}"
    ((FAILED_TESTS++))
fi

# Test DevPi (core Python package index - verify CLI works with authentication)
echo -n "Testing DevPi CLI... "
if [ -n "$DEVPI_URL" ] && [ -n "$DEVPI_USERNAME" ] && [ -n "$DEVPI_PASSWORD" ]; then
    # Use temporary clientdir to avoid conflicts with server URL rewriting
    DEVPI_TEST_DIR=$(mktemp -d)
    # Configure devpi to use the API endpoint (no OAuth2)
    if [ "$VERBOSE" = "1" ]; then
        # Verbose mode - show output
        if devpi use "$DEVPI_URL" --clientdir="$DEVPI_TEST_DIR" && \
           devpi login "$DEVPI_USERNAME" --password="$DEVPI_PASSWORD" --clientdir="$DEVPI_TEST_DIR" && \
           devpi use "$DEVPI_INDEX" --clientdir="$DEVPI_TEST_DIR"; then
            echo -e "${GREEN}✅ PASS${NC}"
            ((PASSED_TESTS++))
        else
            echo -e "${RED}❌ FAIL${NC} (CLI authentication or index access failed)"
            ((FAILED_TESTS++))
        fi
    else
        # Normal mode - suppress output
        if devpi use "$DEVPI_URL" --clientdir="$DEVPI_TEST_DIR" &>/dev/null && \
           devpi login "$DEVPI_USERNAME" --password="$DEVPI_PASSWORD" --clientdir="$DEVPI_TEST_DIR" &>/dev/null && \
           devpi use "$DEVPI_INDEX" --clientdir="$DEVPI_TEST_DIR" &>/dev/null; then
            echo -e "${GREEN}✅ PASS${NC}"
            ((PASSED_TESTS++))
        else
            echo -e "${RED}❌ FAIL${NC} (CLI authentication or index access failed)"
            ((FAILED_TESTS++))
        fi
    fi
    rm -rf "$DEVPI_TEST_DIR"
else
    echo -e "${RED}❌ FAIL${NC} (Environment variables not set)"
    ((FAILED_TESTS++))
fi

# Test PostgreSQL connection (core service - validate credentials work)
test_cli "PostgreSQL connection" "[ -n \"\$POSTGRES_HOST\" ] && [ -n \"\$POSTGRES_PASSWORD\" ]" "python3 -c 'import psycopg2; import os; conn=psycopg2.connect(host=os.environ.get(\"POSTGRES_HOST\"), port=int(os.environ.get(\"POSTGRES_PORT\", 5432)), database=os.environ.get(\"POSTGRES_DB\"), user=os.environ.get(\"POSTGRES_USER\"), password=os.environ.get(\"POSTGRES_PASSWORD\")); cursor=conn.cursor(); cursor.execute(\"SELECT 1\"); cursor.close(); conn.close()' 2>/dev/null"

# Test SeaweedFS S3 API (core service - validate credentials work)
test_cli "SeaweedFS S3 API" "[ -n \"\$SEAWEEDFS_S3_ENDPOINT\" ] && [ -n \"\$SEAWEEDFS_ACCESS_KEY\" ] && [ -n \"\$SEAWEEDFS_SECRET_KEY\" ]" "python3 -c 'import boto3; import os; s3=boto3.client(\"s3\", endpoint_url=os.environ.get(\"SEAWEEDFS_S3_ENDPOINT\"), aws_access_key_id=os.environ.get(\"SEAWEEDFS_ACCESS_KEY\"), aws_secret_access_key=os.environ.get(\"SEAWEEDFS_SECRET_KEY\"), verify=False); s3.list_buckets()' 2>/dev/null"

echo ""
echo "=== Optional Data Services ==="
echo ""

# Test Valkey (Redis-compatible - verify connection, no authentication)
test_cli "Valkey connection" "[ -n \"\$VALKEY_HOST\" ]" "python3 -c 'import redis; import os; r=redis.Redis(host=os.environ.get(\"VALKEY_HOST\"), port=int(os.environ.get(\"VALKEY_PORT\", 6379)), decode_responses=True); r.ping(); r.set(\"test_key\", \"test_value\"); r.delete(\"test_key\")' 2>/dev/null" "optional"

# Test Qdrant (open-source version - no API key authentication)
test_cli "Qdrant vector DB" "[ -n \"\$QDRANT_URL\" ]" "python3 -c 'from qdrant_client import QdrantClient; import os; client=QdrantClient(url=os.environ.get(\"QDRANT_URL\"), port=443, https=True, verify=False); client.get_collections()' 2>/dev/null" "optional"

# Test ClickHouse (verify credentials work with actual query)
test_cli "ClickHouse database" "[ -n \"\$CLICKHOUSE_HOST\" ] && [ -n \"\$CLICKHOUSE_USER\" ] && [ -n \"\$CLICKHOUSE_PASSWORD\" ]" "python3 -c 'import clickhouse_connect; import os; client=clickhouse_connect.get_client(host=os.environ.get(\"CLICKHOUSE_HOST\"), port=int(os.environ.get(\"CLICKHOUSE_HTTP_PORT\", 443)), username=os.environ.get(\"CLICKHOUSE_USER\"), password=os.environ.get(\"CLICKHOUSE_PASSWORD\"), secure=True, verify=False); result=client.query(\"SELECT 1\"); assert result.result_rows[0][0] == 1'" "optional"

# Test NATS (verify connection with authentication)
test_cli "NATS messaging" "[ -n \"\$NATS_URL\" ]" "python3 -c 'import nats, asyncio, os
async def test():
    nc = await nats.connect(os.environ.get(\"NATS_URL\"), tls=None)
    await nc.publish(\"test\", b\"hello\")
    await nc.close()
asyncio.run(test())' 2>/dev/null" "optional"

# Test Chroma (verify token authentication works)
test_cli "Chroma vector DB" "[ -n \"\$CHROMA_API_URL\" ] && [ -n \"\$CHROMA_AUTH_TOKEN\" ]" "python3 -c 'import chromadb; from chromadb.config import Settings; import os; client=chromadb.HttpClient(host=os.environ.get(\"CHROMA_API_URL\").replace(\"https://\", \"\").replace(\"http://\", \"\"), port=443, ssl=True, headers={\"X-Chroma-Token\": os.environ.get(\"CHROMA_AUTH_TOKEN\")}); client.heartbeat()' 2>/dev/null" "optional"

echo ""
echo "=== Optional ML/AI Services ==="
echo ""

# Test Argilla (verify authentication with API key works)
test_cli "Argilla client" "[ -n \"\$ARGILLA_API_KEY\" ]" "python3 -c 'import argilla; import os; import urllib3; urllib3.disable_warnings(); client = argilla.Argilla(api_url=os.environ.get(\"ARGILLA_API_URL\"), api_key=os.environ.get(\"ARGILLA_API_KEY\")); client.me.username' 2>/dev/null" "optional"

# Test CVAT (verify CLI authentication with basic auth on /api/ endpoint)
test_cli "CVAT CLI" "[ -n \"\$CVAT_USERNAME\" ] && [ -n \"\$CVAT_PASSWORD\" ]" "cvat-cli --server-host \"\$CVAT_API_URL\" --auth \"\$CVAT_USERNAME:\$CVAT_PASSWORD\" task ls 2>/dev/null" "optional"

# Test MLflow
echo -n "Testing MLflow config... "
if [ -n "$MLFLOW_TRACKING_URI" ]; then
    # Get MLflow authentication token
    if [ -f ~/mlflow-auth.sh ]; then
        source ~/mlflow-auth.sh > /dev/null 2>&1
    fi

    # Try to connect to MLflow tracking server using Python SDK
    if [ -n "$MLFLOW_TRACKING_TOKEN" ]; then
        export MLFLOW_TRACKING_TOKEN

        # First, do a quick API check to see if user is initialized
        # Using a short timeout to fail fast if user doesn't exist
        QUICK_CHECK=$(timeout 3 python3 -c "import mlflow; mlflow.set_tracking_uri('$MLFLOW_TRACKING_URI'); mlflow.search_experiments()" 2>&1)
        QUICK_EXIT=$?

        if [ $QUICK_EXIT -eq 0 ]; then
            echo -e "${GREEN}✅ PASS${NC} (URI: $MLFLOW_TRACKING_URI)"
            ((PASSED_TESTS++))
        elif [ $QUICK_EXIT -eq 124 ]; then
            # Timeout means the request is hanging - likely user not initialized
            echo -e "${YELLOW}⚠ SETUP REQUIRED${NC}"
            echo ""
            echo "MLflow requires first-time user initialization via web browser."
            echo ""
            echo "Please follow these steps:"
            echo "  1. Open this URL in your browser: ${MLFLOW_TRACKING_URI}"
            echo "  2. Log in with your Keycloak credentials"
            echo "  3. Once you see the MLflow dashboard, your user is initialized"
            echo ""
            read -p "Press ENTER after completing the browser login: "

            # Retry the connection with normal timeout
            MLFLOW_OUTPUT=$(timeout 10 python3 -c "import mlflow; mlflow.set_tracking_uri('$MLFLOW_TRACKING_URI'); mlflow.search_experiments()" 2>&1)
            MLFLOW_EXIT=$?
            if [ $MLFLOW_EXIT -eq 0 ]; then
                echo -e "${GREEN}✅ PASS${NC} (URI: $MLFLOW_TRACKING_URI)"
                ((PASSED_TESTS++))
            else
                echo -e "${RED}❌ FAIL${NC} (Still cannot connect after initialization)"
                echo "Please verify you successfully logged in via the browser"
                ((FAILED_TESTS++))
            fi
        else
            # Other error
            echo -e "${RED}❌ FAIL${NC} (Cannot connect to $MLFLOW_TRACKING_URI)"
            if [ -n "$QUICK_CHECK" ]; then
                echo "Error: $QUICK_CHECK"
            fi
            ((FAILED_TESTS++))
        fi
    else
        echo -e "${RED}❌ FAIL${NC} (Token not set - run 'source ~/mlflow-auth.sh' first)"
        ((FAILED_TESTS++))
    fi
else
    echo -e "${YELLOW}⊘ SKIP (optional service not installed)${NC}"
fi

# Test Perses (verify percli can connect and list dashboards)
test_cli "Perses API" "[ -n \"\$PERSES_URL\" ] && [ -n \"\$PERSES_USER\" ] && [ -n \"\$PERSES_PASSWORD\" ]" "percli config set url \$PERSES_URL && echo \$PERSES_PASSWORD | percli login --username \$PERSES_USER --password-stdin && percli get dashboards --project gpu | head -1" "optional"

# Test OpenSearch (verify connection with credentials from environment)
test_cli "OpenSearch client" "[ -n \"\$OPENSEARCH_URL\" ] && [ -n \"\$OPENSEARCH_USER\" ] && [ -n \"\$OPENSEARCH_PASSWORD\" ]" "python3 -c 'from opensearchpy import OpenSearch; import os; client=OpenSearch([os.environ.get(\"OPENSEARCH_URL\")], http_auth=(os.environ.get(\"OPENSEARCH_USER\"), os.environ.get(\"OPENSEARCH_PASSWORD\")), use_ssl=True, verify_certs=False); client.info()'" "optional"

# Test Weaviate (verify connection with API key from environment)
test_cli "Weaviate client" "[ -n \"\$WEAVIATE_URL\" ] && [ -n \"\$WEAVIATE_API_KEY\" ]" "python3 -c 'import weaviate; from weaviate.auth import AuthApiKey; import os; client=weaviate.connect_to_weaviate_cloud(cluster_url=os.environ.get(\"WEAVIATE_URL\"), auth_credentials=AuthApiKey(os.environ.get(\"WEAVIATE_API_KEY\")), skip_init_checks=True); client.is_ready(); client.close()'" "optional"

# Test LiteLLM
echo -n "Testing LiteLLM config... "
if [ -n "$LITELLM_ENDPOINT" ]; then
    # Test authenticated access to LiteLLM API
    if [ -n "$LITELLM_MASTER_KEY" ]; then
        if curl -s -f -k --max-time 5 -H "Authorization: Bearer $LITELLM_MASTER_KEY" "$LITELLM_ENDPOINT/health" > /dev/null 2>&1; then
            echo -e "${GREEN}✅ PASS${NC} (Endpoint: $LITELLM_ENDPOINT)"
            ((PASSED_TESTS++))
        else
            echo -e "${RED}❌ FAIL${NC} (Cannot connect to $LITELLM_ENDPOINT with authentication)"
            ((FAILED_TESTS++))
        fi
    else
        echo -e "${RED}❌ FAIL${NC} (LITELLM_MASTER_KEY not set)"
        ((FAILED_TESTS++))
    fi
elif grep -q "LITELLM_ENDPOINT" ~/.bashrc 2>/dev/null; then
    echo -e "${YELLOW}⊘ SKIP (configured but not sourced in current shell)${NC}"
else
    echo -e "${YELLOW}⊘ SKIP (optional service not installed)${NC}"
fi

# Test Langfuse (verify API keys work)
test_cli "Langfuse SDK" "[ -f ~/.langfuse/credentials ]" "python3 -c 'from langfuse import Langfuse; import configparser; config=configparser.ConfigParser(); config.read(\"$HOME/.langfuse/credentials\"); langfuse=Langfuse(public_key=config[\"langfuse\"][\"public_key\"], secret_key=config[\"langfuse\"][\"secret_key\"], host=config[\"langfuse\"][\"host\"]); langfuse.auth_check()'" "optional"

echo ""
echo "======================================================================"
echo "  Test Results"
echo "======================================================================"
echo -e "Passed: ${GREEN}${PASSED_TESTS}${NC}"
echo -e "Failed: ${RED}${FAILED_TESTS}${NC}"
echo ""

if [ $FAILED_TESTS -eq 0 ]; then
    echo -e "${GREEN}✅ All configured CLI tools are working correctly!${NC}"
    exit 0
else
    echo -e "${RED}❌ Some CLI tools failed configuration tests.${NC}"
    echo ""
    echo "Troubleshooting:"
    echo "1. Re-run: ./scripts/run_ansible.sh ansible/40_thinkube/core/code-server/15_configure_environment.yaml"
    echo "2. Check logs for specific failures"
    echo "3. Verify all required services are deployed"
    exit 1
fi
