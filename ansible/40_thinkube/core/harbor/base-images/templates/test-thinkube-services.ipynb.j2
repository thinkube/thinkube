{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Thinkube Services Connection Test\n",
    "\n",
    "This notebook tests connectivity to all Thinkube services and validates that credentials are properly configured.\n",
    "\n",
    "**Test Philosophy:**\n",
    "- All tests perform **actual operations** with credentials, not just endpoint checks\n",
    "- Core services **MUST** be configured - tests will **FAIL** if missing\n",
    "- Optional services are **SKIPPED** if not configured\n",
    "- **NO fallback values** - if a required variable is missing, test fails immediately\n",
    "\n",
    "**Expected Results:**\n",
    "- ✅ All core services should pass\n",
    "- ⊘ Optional services may be skipped (normal if not deployed)\n",
    "- ❌ Any failures indicate misconfiguration\n",
    "\n",
    "Run all cells to validate your environment setup."
   ],
   "id": "introduction"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import required libraries\n",
    "import os\n",
    "import sys\n",
    "from pathlib import Path\n",
    "from IPython.display import display, HTML\n",
    "\n",
    "# Color-coded output helpers\n",
    "def print_success(msg):\n",
    "    display(HTML(f'<span style=\"color: #00c896; font-weight: bold;\">✅ {msg}</span>'))\n",
    "\n",
    "def print_error(msg):\n",
    "    display(HTML(f'<span style=\"color: #e74c3c; font-weight: bold;\">❌ {msg}</span>'))\n",
    "\n",
    "def print_warning(msg):\n",
    "    display(HTML(f'<span style=\"color: #ff8c42; font-weight: bold;\">⚠️  {msg}</span>'))\n",
    "\n",
    "def print_info(msg):\n",
    "    display(HTML(f'<span style=\"color: #3498db; font-weight: bold;\">ℹ️  {msg}</span>'))\n",
    "\n",
    "def print_section(msg):\n",
    "    display(HTML(f'<h3 style=\"color: #006680; margin-top: 20px;\">{msg}</h3>'))\n",
    "\n",
    "def print_skip(msg):\n",
    "    display(HTML(f'<span style=\"color: #95a5a6; font-weight: bold;\">⊘ {msg}</span>'))"
   ],
   "id": "helper-functions"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Core Infrastructure Services\n",
    "\n",
    "These services provide foundational infrastructure and **MUST** work."
   ],
   "id": "section-core-infrastructure"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Kubernetes API\")\n",
    "\n",
    "try:\n",
    "    from kubernetes import client, config\n",
    "    \n",
    "    config.load_kube_config()\n",
    "    v1 = client.CoreV1Api()\n",
    "    namespaces = v1.list_namespace()\n",
    "    \n",
    "    print_success(\"Connected to Kubernetes API\")\n",
    "    print_info(f\"Namespaces: {len(namespaces.items)}\")\n",
    "    \n",
    "except ImportError:\n",
    "    print_error(\"kubernetes python client not installed\")\n",
    "except Exception as e:\n",
    "    print_error(f\"Kubernetes connection failed: {str(e)}\")"
   ],
   "id": "test-kubernetes"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"PostgreSQL Database\")\n",
    "\n",
    "try:\n",
    "    import psycopg2\n",
    "    \n",
    "    # Check ALL required variables first\n",
    "    postgres_host = os.environ.get('POSTGRES_HOST')\n",
    "    postgres_password = os.environ.get('POSTGRES_PASSWORD')\n",
    "    postgres_port = os.environ.get('POSTGRES_PORT')\n",
    "    postgres_db = os.environ.get('POSTGRES_DB')\n",
    "    postgres_user = os.environ.get('POSTGRES_USER')\n",
    "    \n",
    "    if not postgres_host or not postgres_password:\n",
    "        print_error(\"PostgreSQL not configured: missing POSTGRES_HOST or POSTGRES_PASSWORD\")\n",
    "    else:\n",
    "        # All required vars present, run test\n",
    "        conn = psycopg2.connect(\n",
    "            host=postgres_host,\n",
    "            port=int(postgres_port),\n",
    "            database=postgres_db,\n",
    "            user=postgres_user,\n",
    "            password=postgres_password\n",
    "        )\n",
    "        cursor = conn.cursor()\n",
    "        cursor.execute('SELECT version();')\n",
    "        version = cursor.fetchone()[0]\n",
    "        print_success(f\"Connected to PostgreSQL at {postgres_host}\")\n",
    "        print_info(f\"Version: {version.split(',')[0]}\")\n",
    "        cursor.close()\n",
    "        conn.close()\n",
    "        \n",
    "except ImportError:\n",
    "    print_error(\"psycopg2-binary not installed\")\n",
    "except Exception as e:\n",
    "    print_error(f\"PostgreSQL connection failed: {str(e)}\")"
   ],
   "id": "test-postgresql"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"SeaweedFS (S3-Compatible Storage)\")\n",
    "\n",
    "try:\n",
    "    import boto3\n",
    "    from botocore.exceptions import ClientError\n",
    "    \n",
    "    # Check ALL required variables first\n",
    "    s3_endpoint = os.environ.get('SEAWEEDFS_S3_ENDPOINT')\n",
    "    s3_access_key = os.environ.get('SEAWEEDFS_ACCESS_KEY')\n",
    "    s3_secret_key = os.environ.get('SEAWEEDFS_SECRET_KEY')\n",
    "    \n",
    "    if not s3_endpoint or not s3_access_key or not s3_secret_key:\n",
    "        print_error(\"SeaweedFS not configured: missing SEAWEEDFS_S3_ENDPOINT, ACCESS_KEY, or SECRET_KEY\")\n",
    "    else:\n",
    "        # All required vars present, run test\n",
    "        s3_client = boto3.client(\n",
    "            's3',\n",
    "            endpoint_url=s3_endpoint,\n",
    "            aws_access_key_id=s3_access_key,\n",
    "            aws_secret_access_key=s3_secret_key,\n",
    "            verify=False\n",
    "        )\n",
    "        \n",
    "        response = s3_client.list_buckets()\n",
    "        print_success(f\"Connected to S3 at {s3_endpoint}\")\n",
    "        print_info(f\"Buckets: {len(response['Buckets'])}\")\n",
    "        \n",
    "        if response['Buckets']:\n",
    "            for bucket in response['Buckets'][:5]:\n",
    "                print_info(f\"  - {bucket['Name']}\")\n",
    "                \n",
    "except ImportError:\n",
    "    print_error(\"boto3 not installed\")\n",
    "except Exception as e:\n",
    "    print_error(f\"S3 connection failed: {str(e)}\")"
   ],
   "id": "test-seaweedfs"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Core Development Tools\n",
    "\n",
    "These tools are used for development workflows."
   ],
   "id": "section-core-dev-tools"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"GitHub\")\n",
    "\n",
    "github_token = os.environ.get('GITHUB_TOKEN')\n",
    "\n",
    "if not github_token:\n",
    "    print_skip(\"GitHub not configured (optional - GITHUB_TOKEN not set)\")\n",
    "else:\n",
    "    try:\n",
    "        from github import Github\n",
    "        \n",
    "        g = Github(github_token)\n",
    "        user = g.get_user()\n",
    "        \n",
    "        print_success(\"Connected to GitHub\")\n",
    "        print_info(f\"User: {user.login}\")\n",
    "        print_info(f\"Repositories: {user.public_repos}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"PyGithub not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"GitHub connection failed: {str(e)}\")"
   ],
   "id": "test-github"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"ArgoCD\")\n",
    "\n",
    "argocd_server = os.environ.get('ARGOCD_SERVER')\n",
    "argocd_token = os.environ.get('ARGOCD_AUTH_TOKEN')\n",
    "\n",
    "if not argocd_server:\n",
    "    print_skip(\"ArgoCD not configured (optional - ARGOCD_SERVER not set)\")\n",
    "else:\n",
    "    try:\n",
    "        import requests\n",
    "        import urllib3\n",
    "        urllib3.disable_warnings()\n",
    "        \n",
    "        if not argocd_token:\n",
    "            print_error(\"ArgoCD token not set (ARGOCD_AUTH_TOKEN required)\")\n",
    "        else:\n",
    "            # Test connection with API call\n",
    "            headers = {'Authorization': f'Bearer {argocd_token}'}\n",
    "            response = requests.get(\n",
    "                f'{argocd_server}/api/v1/applications',\n",
    "                headers=headers,\n",
    "                verify=False\n",
    "            )\n",
    "            response.raise_for_status()\n",
    "            apps = response.json()\n",
    "            \n",
    "            print_success(f\"Connected to ArgoCD at {argocd_server}\")\n",
    "            print_info(f\"Applications: {len(apps['items']) if 'items' in apps else 0}\")\n",
    "            \n",
    "    except ImportError:\n",
    "        print_error(\"requests library not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"ArgoCD connection failed: {str(e)}\")"
   ],
   "id": "test-argocd"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Argo Workflows\")\n",
    "\n",
    "argo_server = os.environ.get('ARGO_SERVER')\n",
    "argo_token = os.environ.get('ARGO_TOKEN')\n",
    "\n",
    "if not argo_server:\n",
    "    print_skip(\"Argo Workflows not configured (optional - ARGO_SERVER not set)\")\n",
    "else:\n",
    "    try:\n",
    "        from hera.workflows import WorkflowsService\n",
    "        \n",
    "        if not argo_token:\n",
    "            print_error(\"Argo Workflows token not set (ARGO_TOKEN required)\")\n",
    "        else:\n",
    "            # Connect using Hera SDK\n",
    "            ws = WorkflowsService(\n",
    "                host=argo_server,\n",
    "                token=argo_token,\n",
    "                verify_ssl=False\n",
    "            )\n",
    "            \n",
    "            # Test by listing workflows\n",
    "            workflows = ws.list_workflows(namespace='argo')\n",
    "            \n",
    "            print_success(f\"Connected to Argo Workflows at {argo_server}\")\n",
    "            print_info(f\"Workflows: {len(workflows.items) if workflows.items else 0}\")\n",
    "            \n",
    "    except ImportError:\n",
    "        print_error(\"hera-workflows not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Argo Workflows connection failed: {str(e)}\")"
   ],
   "id": "test-argo-workflows"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Gitea\")\n",
    "\n",
    "gitea_url = os.environ.get('GITEA_URL')\n",
    "gitea_token = os.environ.get('GITEA_TOKEN')\n",
    "\n",
    "if not gitea_url:\n",
    "    print_skip(\"Gitea not configured (optional - GITEA_URL not set)\")\n",
    "else:\n",
    "    try:\n",
    "        import requests\n",
    "        import urllib3\n",
    "        urllib3.disable_warnings()\n",
    "        \n",
    "        if not gitea_token:\n",
    "            print_error(\"Gitea token not set (GITEA_TOKEN required)\")\n",
    "        else:\n",
    "            # Test connection with API call\n",
    "            headers = {'Authorization': f'token {gitea_token}'}\n",
    "            response = requests.get(\n",
    "                f'{gitea_url}/api/v1/user',\n",
    "                headers=headers,\n",
    "                verify=False\n",
    "            )\n",
    "            response.raise_for_status()\n",
    "            user = response.json()\n",
    "            \n",
    "            print_success(f\"Connected to Gitea at {gitea_url}\")\n",
    "            print_info(f\"User: {user.get('username', 'unknown')}\")\n",
    "            \n",
    "    except ImportError:\n",
    "        print_error(\"requests library not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Gitea connection failed: {str(e)}\")"
   ],
   "id": "test-gitea"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Perses\")\n",
    "\n",
    "perses_url = os.environ.get('PERSES_URL')\n",
    "perses_user = os.environ.get('PERSES_USER')\n",
    "perses_password = os.environ.get('PERSES_PASSWORD')\n",
    "\n",
    "if not perses_url:\n",
    "    print_skip(\"Perses not configured (optional - PERSES_URL not set)\")\n",
    "else:\n",
    "    try:\n",
    "        import requests\n",
    "        import urllib3\n",
    "        urllib3.disable_warnings()\n",
    "        \n",
    "        if not perses_user or not perses_password:\n",
    "            print_error(\"Perses credentials not set (PERSES_USER and PERSES_PASSWORD required)\")\n",
    "        else:\n",
    "            # Test connection with API call using basic auth\n",
    "            response = requests.get(\n",
    "                f'{perses_url}/api/v1/health',\n",
    "                auth=(perses_user, perses_password),\n",
    "                verify=False\n",
    "            )\n",
    "            response.raise_for_status()\n",
    "            \n",
    "            print_success(f\"Connected to Perses at {perses_url}\")\n",
    "            print_info(\"Health check passed\")\n",
    "            \n",
    "    except ImportError:\n",
    "        print_error(\"requests library not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Perses connection failed: {str(e)}\")"
   ],
   "id": "test-perses"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Optional Data Services\n",
    "\n",
    "These services may not be deployed in all installations."
   ],
   "id": "section-optional-data"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Valkey (Redis-Compatible)\")\n",
    "\n",
    "valkey_host = os.environ.get('VALKEY_HOST')\n",
    "\n",
    "if not valkey_host:\n",
    "    print_skip(\"Valkey not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import redis\n",
    "        \n",
    "        valkey_port = os.environ.get('VALKEY_PORT')\n",
    "        \n",
    "        if not valkey_port:\n",
    "            print_error(\"Valkey port not set (VALKEY_PORT required)\")\n",
    "        else:\n",
    "            # Connect without SSL (Valkey uses plain TCP)\n",
    "            client = redis.Redis(\n",
    "                host=valkey_host,\n",
    "                port=int(valkey_port),\n",
    "                decode_responses=True\n",
    "            )\n",
    "            \n",
    "            client.ping()\n",
    "            info = client.info('server')\n",
    "            \n",
    "            # Test read/write\n",
    "            client.set('thinkube:test', 'hello from jupyter')\n",
    "            value = client.get('thinkube:test')\n",
    "            client.delete('thinkube:test')\n",
    "            \n",
    "            print_success(f\"Connected to Valkey at {valkey_host}\")\n",
    "            print_info(f\"Version: {info.get('redis_version', 'unknown')}\")\n",
    "            print_info(\"Read/write operations working\")\n",
    "            \n",
    "    except ImportError:\n",
    "        print_error(\"redis library not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Valkey connection failed: {str(e)}\")"
   ],
   "id": "test-valkey"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Qdrant Vector Database\")\n",
    "\n",
    "qdrant_url = os.environ.get('QDRANT_URL')\n",
    "\n",
    "if not qdrant_url:\n",
    "    print_skip(\"Qdrant not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        from qdrant_client import QdrantClient\n",
    "        \n",
    "        # Connect via external HTTPS (port 443)\n",
    "        client = QdrantClient(\n",
    "            url=qdrant_url,\n",
    "            port=443,\n",
    "            https=True,\n",
    "            verify=False\n",
    "        )\n",
    "        \n",
    "        collections = client.get_collections()\n",
    "        \n",
    "        print_success(f\"Connected to Qdrant at {qdrant_url}\")\n",
    "        print_info(f\"Collections: {len(collections.collections)}\")\n",
    "        \n",
    "        if collections.collections:\n",
    "            for col in collections.collections[:5]:\n",
    "                print_info(f\"  - {col.name}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"qdrant-client not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Qdrant connection failed: {str(e)}\")"
   ],
   "id": "test-qdrant"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"ClickHouse Analytics Database\")\n",
    "\n",
    "clickhouse_host = os.environ.get('CLICKHOUSE_HOST')\n",
    "\n",
    "if not clickhouse_host:\n",
    "    print_skip(\"ClickHouse not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import clickhouse_connect\n",
    "        \n",
    "        clickhouse_user = os.environ.get('CLICKHOUSE_USER')\n",
    "        clickhouse_password = os.environ.get('CLICKHOUSE_PASSWORD')\n",
    "        clickhouse_port = os.environ.get('CLICKHOUSE_HTTP_PORT')\n",
    "        \n",
    "        if not clickhouse_user or not clickhouse_password or not clickhouse_port:\n",
    "            print_error(\"ClickHouse not fully configured: missing USER, PASSWORD, or HTTP_PORT\")\n",
    "        else:\n",
    "            client = clickhouse_connect.get_client(\n",
    "                host=clickhouse_host,\n",
    "                port=int(clickhouse_port),\n",
    "                username=clickhouse_user,\n",
    "                password=clickhouse_password,\n",
    "                secure=True,\n",
    "                verify=False\n",
    "            )\n",
    "            \n",
    "            result = client.query('SELECT version()')\n",
    "            version = result.result_rows[0][0]\n",
    "            \n",
    "            print_success(f\"Connected to ClickHouse at {clickhouse_host}\")\n",
    "            print_info(f\"Version: {version}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"clickhouse-connect not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"ClickHouse connection failed: {str(e)}\")"
   ],
   "id": "test-clickhouse"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"NATS Messaging\")\n",
    "\n",
    "nats_url = os.environ.get('NATS_URL')\n",
    "\n",
    "if not nats_url:\n",
    "    print_skip(\"NATS not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import nats\n",
    "        import asyncio\n",
    "        \n",
    "        async def test_nats():\n",
    "            nc = await nats.connect(nats_url, tls=None)\n",
    "            await nc.publish(\"thinkube.test\", b\"hello from jupyter\")\n",
    "            await nc.close()\n",
    "            return True\n",
    "        \n",
    "        result = await test_nats()\n",
    "        \n",
    "        print_success(f\"Connected to NATS at {nats_url}\")\n",
    "        print_info(\"Publish operation successful\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"nats-py not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"NATS connection failed: {str(e)}\")"
   ],
   "id": "test-nats"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Chroma Vector Database\")\n",
    "\n",
    "chroma_url = os.environ.get('CHROMA_API_URL')\n",
    "\n",
    "if not chroma_url:\n",
    "    print_skip(\"Chroma not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import chromadb\n",
    "        \n",
    "        chroma_token = os.environ.get('CHROMA_AUTH_TOKEN')\n",
    "        \n",
    "        if not chroma_token:\n",
    "            print_error(\"Chroma token not set (CHROMA_AUTH_TOKEN required)\")\n",
    "        else:\n",
    "            # Remove protocol from URL for HttpClient\n",
    "            chroma_host = chroma_url.replace('https://', '').replace('http://', '')\n",
    "            \n",
    "            # Connect via external HTTPS (port 443)\n",
    "            client = chromadb.HttpClient(\n",
    "                host=chroma_host,\n",
    "                port=443,\n",
    "                ssl=True,\n",
    "                headers={\"X-Chroma-Token\": chroma_token}\n",
    "            )\n",
    "            \n",
    "            heartbeat = client.heartbeat()\n",
    "            \n",
    "            print_success(f\"Connected to Chroma at {chroma_url}\")\n",
    "            print_info(f\"Heartbeat: {heartbeat}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"chromadb not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Chroma connection failed: {str(e)}\")"
   ],
   "id": "test-chroma"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"OpenSearch\")\n",
    "\n",
    "opensearch_url = os.environ.get('OPENSEARCH_URL')\n",
    "\n",
    "if not opensearch_url:\n",
    "    print_skip(\"OpenSearch not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        from opensearchpy import OpenSearch\n",
    "        \n",
    "        opensearch_user = os.environ.get('OPENSEARCH_USER')\n",
    "        opensearch_password = os.environ.get('OPENSEARCH_PASSWORD')\n",
    "        \n",
    "        if not opensearch_user or not opensearch_password:\n",
    "            print_error(\"OpenSearch not fully configured: missing USER or PASSWORD\")\n",
    "        else:\n",
    "            client = OpenSearch(\n",
    "                [opensearch_url],\n",
    "                http_auth=(opensearch_user, opensearch_password),\n",
    "                use_ssl=True,\n",
    "                verify_certs=False\n",
    "            )\n",
    "            \n",
    "            info = client.info()\n",
    "            \n",
    "            print_success(f\"Connected to OpenSearch at {opensearch_url}\")\n",
    "            print_info(f\"Version: {info['version']['number']}\")\n",
    "            print_info(f\"Cluster: {info['cluster_name']}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"opensearch-py not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"OpenSearch connection failed: {str(e)}\")"
   ],
   "id": "test-opensearch"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Weaviate Vector Database\")\n",
    "\n",
    "weaviate_url = os.environ.get('WEAVIATE_URL')\n",
    "\n",
    "if not weaviate_url:\n",
    "    print_skip(\"Weaviate not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import weaviate\n",
    "        from weaviate.auth import AuthApiKey\n",
    "        \n",
    "        weaviate_api_key = os.environ.get('WEAVIATE_API_KEY')\n",
    "        \n",
    "        if not weaviate_api_key:\n",
    "            print_error(\"Weaviate API key not set (WEAVIATE_API_KEY required)\")\n",
    "        else:\n",
    "            client = weaviate.connect_to_weaviate_cloud(\n",
    "                cluster_url=weaviate_url,\n",
    "                auth_credentials=AuthApiKey(weaviate_api_key),\n",
    "                skip_init_checks=True\n",
    "            )\n",
    "            \n",
    "            is_ready = client.is_ready()\n",
    "            \n",
    "            print_success(f\"Connected to Weaviate at {weaviate_url}\")\n",
    "            print_info(f\"Ready: {is_ready}\")\n",
    "            \n",
    "            client.close()\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"weaviate-client not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Weaviate connection failed: {str(e)}\")"
   ],
   "id": "test-weaviate"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Optional ML/AI Services\n",
    "\n",
    "These services support machine learning and AI workflows."
   ],
   "id": "section-optional-mlai"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Argilla Data Labeling\")\n",
    "\n",
    "argilla_url = os.environ.get('ARGILLA_API_URL')\n",
    "\n",
    "if not argilla_url:\n",
    "    print_skip(\"Argilla not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import argilla\n",
    "        import urllib3\n",
    "        urllib3.disable_warnings()\n",
    "        \n",
    "        argilla_api_key = os.environ.get('ARGILLA_API_KEY')\n",
    "        \n",
    "        if not argilla_api_key:\n",
    "            print_error(\"Argilla API key not set (ARGILLA_API_KEY required)\")\n",
    "        else:\n",
    "            client = argilla.Argilla(\n",
    "                api_url=argilla_url,\n",
    "                api_key=argilla_api_key\n",
    "            )\n",
    "            \n",
    "            username = client.me.username\n",
    "            \n",
    "            print_success(f\"Connected to Argilla at {argilla_url}\")\n",
    "            print_info(f\"User: {username}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"argilla not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Argilla connection failed: {str(e)}\")"
   ],
   "id": "test-argilla"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"CVAT (Computer Vision Annotation Tool)\")\n",
    "\n",
    "cvat_url = os.environ.get('CVAT_API_URL')\n",
    "\n",
    "if not cvat_url:\n",
    "    print_skip(\"CVAT not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        from cvat_sdk import make_client\n",
    "        \n",
    "        cvat_username = os.environ.get('CVAT_USERNAME')\n",
    "        cvat_password = os.environ.get('CVAT_PASSWORD')\n",
    "        \n",
    "        if not cvat_username or not cvat_password:\n",
    "            print_error(\"CVAT not fully configured: missing USERNAME or PASSWORD\")\n",
    "        else:\n",
    "            client = make_client(\n",
    "                host=cvat_url,\n",
    "                credentials=(cvat_username, cvat_password)\n",
    "            )\n",
    "            \n",
    "            # Test by listing projects\n",
    "            projects = list(client.projects.list())\n",
    "            \n",
    "            print_success(f\"Connected to CVAT at {cvat_url}\")\n",
    "            print_info(f\"Projects: {len(projects)}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"cvat-sdk not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"CVAT connection failed: {str(e)}\")"
   ],
   "id": "test-cvat"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"MLflow Experiment Tracking\")\n",
    "\n",
    "mlflow_uri = os.environ.get('MLFLOW_TRACKING_URI')\n",
    "\n",
    "if not mlflow_uri:\n",
    "    print_skip(\"MLflow not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import mlflow\n",
    "        import requests\n",
    "        import json\n",
    "        import urllib3\n",
    "        urllib3.disable_warnings()\n",
    "        \n",
    "        # Get Keycloak credentials from environment\n",
    "        mlflow_username = os.environ.get('MLFLOW_AUTH_USERNAME')\n",
    "        mlflow_password = os.environ.get('MLFLOW_AUTH_PASSWORD')\n",
    "        token_url = os.environ.get('MLFLOW_KEYCLOAK_TOKEN_URL')\n",
    "        client_id = os.environ.get('MLFLOW_KEYCLOAK_CLIENT_ID')\n",
    "        client_secret = os.environ.get('MLFLOW_CLIENT_SECRET')\n",
    "        \n",
    "        if not all([mlflow_username, mlflow_password, token_url, client_id, client_secret]):\n",
    "            print_error(\"MLflow OAuth not fully configured: missing credentials\")\n",
    "        else:\n",
    "            # Get OAuth token from Keycloak\n",
    "            token_response = requests.post(\n",
    "                token_url,\n",
    "                headers={'Content-Type': 'application/x-www-form-urlencoded'},\n",
    "                data={\n",
    "                    'grant_type': 'password',\n",
    "                    'client_id': client_id,\n",
    "                    'client_secret': client_secret,\n",
    "                    'username': mlflow_username,\n",
    "                    'password': mlflow_password\n",
    "                },\n",
    "                verify=False,\n",
    "                timeout=10\n",
    "            )\n",
    "            \n",
    "            if token_response.status_code == 200:\n",
    "                token_data = token_response.json()\n",
    "                mlflow_token = token_data.get('access_token')\n",
    "                \n",
    "                if mlflow_token:\n",
    "                    # Set token and test MLflow\n",
    "                    os.environ['MLFLOW_TRACKING_TOKEN'] = mlflow_token\n",
    "                    mlflow.set_tracking_uri(mlflow_uri)\n",
    "                    \n",
    "                    experiments = mlflow.search_experiments(max_results=5)\n",
    "                    \n",
    "                    print_success(f\"Connected to MLflow at {mlflow_uri}\")\n",
    "                    print_info(f\"Experiments found: {len(experiments)}\")\n",
    "                    \n",
    "                    if experiments:\n",
    "                        for exp in experiments:\n",
    "                            print_info(f\"  - {exp.name}\")\n",
    "                else:\n",
    "                    print_error(\"Failed to extract access token from Keycloak response\")\n",
    "            else:\n",
    "                print_error(f\"OAuth authentication failed: {token_response.status_code}\")\n",
    "                print_info(\"Check MLFLOW_AUTH_USERNAME and MLFLOW_AUTH_PASSWORD\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"mlflow or requests not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"MLflow connection failed: {str(e)}\")"
   ],
   "id": "test-mlflow"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"LiteLLM Proxy\")\n",
    "\n",
    "litellm_endpoint = os.environ.get('LITELLM_ENDPOINT')\n",
    "\n",
    "if not litellm_endpoint:\n",
    "    print_skip(\"LiteLLM not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        import requests\n",
    "        import urllib3\n",
    "        urllib3.disable_warnings()\n",
    "        \n",
    "        litellm_key = os.environ.get('LITELLM_MASTER_KEY')\n",
    "        \n",
    "        if not litellm_key:\n",
    "            print_error(\"LiteLLM master key not set (LITELLM_MASTER_KEY required)\")\n",
    "        else:\n",
    "            response = requests.get(\n",
    "                f\"{litellm_endpoint}/health\",\n",
    "                headers={\"Authorization\": f\"Bearer {litellm_key}\"},\n",
    "                verify=False,\n",
    "                timeout=5\n",
    "            )\n",
    "            \n",
    "            if response.status_code == 200:\n",
    "                print_success(f\"Connected to LiteLLM at {litellm_endpoint}\")\n",
    "                print_info(\"Health check passed\")\n",
    "            else:\n",
    "                print_error(f\"LiteLLM returned status {response.status_code}\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"requests not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"LiteLLM connection failed: {str(e)}\")"
   ],
   "id": "test-litellm"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print_section(\"Langfuse LLM Observability\")\n",
    "\n",
    "langfuse_host = os.environ.get('LANGFUSE_HOST')\n",
    "\n",
    "if not langfuse_host:\n",
    "    print_skip(\"Langfuse not configured (optional service)\")\n",
    "else:\n",
    "    try:\n",
    "        from langfuse import Langfuse\n",
    "        \n",
    "        langfuse_public_key = os.environ.get('LANGFUSE_PUBLIC_KEY')\n",
    "        langfuse_secret_key = os.environ.get('LANGFUSE_SECRET_KEY')\n",
    "        \n",
    "        if not langfuse_public_key or not langfuse_secret_key:\n",
    "            print_error(\"Langfuse not fully configured: missing PUBLIC_KEY or SECRET_KEY\")\n",
    "        else:\n",
    "            langfuse = Langfuse(\n",
    "                public_key=langfuse_public_key,\n",
    "                secret_key=langfuse_secret_key,\n",
    "                host=langfuse_host\n",
    "            )\n",
    "            \n",
    "            auth_check = langfuse.auth_check()\n",
    "            \n",
    "            print_success(f\"Connected to Langfuse at {langfuse_host}\")\n",
    "            print_info(\"Authentication successful\")\n",
    "        \n",
    "    except ImportError:\n",
    "        print_error(\"langfuse not installed\")\n",
    "    except Exception as e:\n",
    "        print_error(f\"Langfuse connection failed: {str(e)}\")"
   ],
   "id": "test-langfuse"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Summary\n",
    "\n",
    "**Configuration Guide:**\n",
    "\n",
    "1. **Service Endpoints** - Automatically configured from:\n",
    "   - `.thinkube_env` (core services in Docker image)\n",
    "   - `.config/thinkube/service-env.sh` (optional services from service discovery)\n",
    "\n",
    "2. **User Secrets** - Configure via thinkube-control:\n",
    "   - Navigate to https://control.{{ domain_name }}/settings/api-secrets\n",
    "   - Add your API keys and tokens\n",
    "   - Add service passwords\n",
    "   - Restart your Jupyter server to load new secrets\n",
    "\n",
    "**Troubleshooting:**\n",
    "\n",
    "- If environment variables are missing, check that `.thinkube_env` exists in your home directory\n",
    "- For optional services, verify they are deployed in your Kubernetes cluster\n",
    "- For password/API key issues, verify they are configured in thinkube-control\n",
    "- Some services (MLflow) require browser authentication before API access works\n",
    "\n",
    "**Testing Philosophy:**\n",
    "\n",
    "All tests perform **actual operations** with credentials to ensure:\n",
    "- Credentials are available in the environment\n",
    "- Authentication succeeds\n",
    "- Service responds correctly to authenticated requests\n",
    "\n",
    "This validates the complete stack: DNS → Ingress → TLS → Service → Authentication → Backend."
   ],
   "id": "summary"
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
