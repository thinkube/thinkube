# Copyright 2025 Alejandro MartÃ­nez CorriÃ¡ and the Thinkube contributors
# SPDX-License-Identifier: Apache-2.0

---
# ansible/40_thinkube/core/harbor/10_deploy.yaml
# Description:
#   Deploys Harbor container registry with OIDC authentication via Keycloak
#   Creates Keycloak client, configures OIDC scopes, and sets up harbor-admins group
#   Uses Helm chart for deployment with ingress exposure
#
#   EXCEPTION: Harbor's built-in admin username cannot be changed from "admin"
#   We change its password to our standard admin_password for consistency
#
# Requirements:
#   - Canonical k8s-snap installed with storage addon enabled
#   - Keycloak must be deployed and accessible
#   - Wildcard TLS certificate available in default namespace
#   - KEYCLOAK_ADMIN_PASSWORD environment variable set
#
# Usage:
#   cd ~/thinkube
#   ./scripts/run_ansible.sh ansible/40_thinkube/core/harbor/10_deploy.yaml
#
# Variables from inventory:
#   - admin_username: Admin user for Keycloak and harbor-admins group
#   - domain_name: Base domain for services
#   - keycloak_url: Keycloak server URL
#   - keycloak_realm: Keycloak realm for services
#   - primary_ingress_class: Ingress class to use
#   - harbor_namespace: Namespace for Harbor deployment
#   - harbor_registry: Harbor registry domain
#   - harbor_release: Helm release name
#   - kubectl_bin: Path to kubectl binary
#   - helm_bin: Path to helm binary
#
# Environment Variables:
#   - ADMIN_PASSWORD: Required for Keycloak authentication
#
# ðŸ¤– [AI-assisted]

- name: Deploy Harbor with LoadBalancer Exposure and OIDC Authentication
  hosts: k8s_control_plane
  gather_facts: false
  vars:
    harbor_values: "/tmp/harbor-values.yaml"
    harbor_admin_user: "admin"  # Harbor's built-in admin user (EXCEPTION: Cannot be changed)
    admin_password: "{{ lookup('env', 'ADMIN_PASSWORD') | default(lookup('env', 'ANSIBLE_BECOME_PASSWORD'), true) }}"

    # OIDC configuration
    oidc_client_id: "harbor"
    oidc_group_claim: "groups"
    oidc_admin_group: "harbor-admins"
    oidc_scopes: "openid,profile,email,groups"

  pre_tasks:
    - name: Verify admin password available
      ansible.builtin.assert:
        that: admin_password != ''
        fail_msg: "ADMIN_PASSWORD environment variable must be set"
        success_msg: "Required environment variables are set"

  tasks:
    ########################################################################
    # 1. Build Harbor ARM64/AMD64 Images
    ########################################################################
    # Harbor v2.14.0 doesn't provide official ARM64 images, so we build our own
    # using the multi-arch branch from https://github.com/ranimandepudi/harbor
    # Images are built on the control plane node and Harbor is pinned there
    # to ensure architecture compatibility.

    - name: Check if Harbor source already exists
      ansible.builtin.stat:
        path: /tmp/harbor-build
      register: harbor_src

    - name: Remove existing Harbor source if present
      ansible.builtin.file:
        path: /tmp/harbor-build
        state: absent
      when: harbor_src.stat.exists

    - name: Clone Harbor repository with multi-arch support
      ansible.builtin.git:
        repo: "https://github.com/ranimandepudi/harbor.git"
        dest: /tmp/harbor-build
        version: "multiarch-platform-support"
        depth: 1

    - name: Install build dependencies
      ansible.builtin.package:
        name:
          - golang
          - make
          - git
          - podman
        state: present
      become: true

    - name: Build Harbor images for host architecture
      ansible.builtin.shell: |
        cd /tmp/harbor-build
        make package_online GOBUILDTAGS="include_oss include_gcs" VERSIONTAG=v2.14.0 PKGVERSIONTAG=v2.14.0
      register: harbor_build
      changed_when: true
      async: 3600
      poll: 60

    - name: Tag Harbor images with tk-harbor prefix
      ansible.builtin.command:
        cmd: "podman tag goharbor/{{ item }}:v2.14.0 tk-harbor-{{ item }}:v2.14.0"
      loop:
        - harbor-core
        - harbor-db
        - harbor-jobservice
        - harbor-portal
        - harbor-registryctl
        - registry-photon
        - redis-photon
        - trivy-adapter-photon
      register: tag_result
      changed_when: true
      failed_when: false

    - name: Save Harbor images to tar files
      ansible.builtin.command:
        cmd: "podman save -o /tmp/harbor-build/tk-harbor-{{ item }}.tar tk-harbor-{{ item }}:v2.14.0"
      loop:
        - harbor-core
        - harbor-db
        - harbor-jobservice
        - harbor-portal
        - harbor-registryctl
        - registry-photon
        - redis-photon
        - trivy-adapter-photon
      changed_when: true

    - name: Import Harbor images into containerd
      ansible.builtin.shell: |
        sudo /snap/k8s/current/bin/ctr --address /run/containerd/containerd.sock \
          --namespace k8s.io images import /tmp/harbor-build/tk-harbor-{{ item }}.tar
      loop:
        - harbor-core
        - harbor-db
        - harbor-jobservice
        - harbor-portal
        - harbor-registryctl
        - registry-photon
        - redis-photon
        - trivy-adapter-photon
      changed_when: true

    - name: Clean up tar files
      ansible.builtin.file:
        path: "/tmp/harbor-build/tk-harbor-{{ item }}.tar"
        state: absent
      loop:
        - harbor-core
        - harbor-db
        - harbor-jobservice
        - harbor-portal
        - harbor-registryctl
        - registry-photon
        - redis-photon
        - trivy-adapter-photon

    - name: Get control plane hostname for nodeSelector
      ansible.builtin.set_fact:
        control_plane_hostname: "{{ inventory_hostname }}"

    ########################################################################
    # 2. Keycloak OIDC Client, Scope Setup, harbor-admins Group
    ########################################################################

    - name: Get Keycloak admin token
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/realms/master/protocol/openid-connect/token"
        method: POST
        body_format: form-urlencoded
        body:
          username: "{{ admin_username }}"
          password: "{{ admin_password }}"
          grant_type: password
          client_id: "admin-cli"
        validate_certs: false  # TODO: Set to true once DNS resolves properly for auth.{{ domain_name }}
        status_code: [200, 201]
      register: keycloak_token
      no_log: true

    - name: Ensure harbor client exists
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/clients"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          clientId: "{{ oidc_client_id }}"
          enabled: true
          protocol: "openid-connect"
          publicClient: false
          redirectUris:
            - "https://{{ harbor_registry }}/c/oidc/callback"
          baseUrl: "https://{{ harbor_registry }}"
          attributes:
            post.logout.redirect.uris: "+"
        status_code: [201, 409]
        validate_certs: false  # Self-signed certificate during initial deployment
      register: harbor_client_creation

    - name: Get harbor client ID
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/clients?clientId={{ oidc_client_id }}"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        status_code: 200
        validate_certs: false  # Self-signed certificate during initial deployment
      register: harbor_client_info

    - name: Set harbor client UUID fact
      ansible.builtin.set_fact:
        harbor_client_uuid: >-
          {{ (harbor_client_info.json[0].id if harbor_client_info.json | length > 0 else
          harbor_client_creation.json.id) }}

    - name: Ensure OIDC scopes exist
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/client-scopes"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "{{ item.name }}"
          description: "{{ item.description }}"
          protocol: "openid-connect"
        status_code: [201, 409]
        validate_certs: false  # Self-signed certificate during initial deployment
      loop:
        - { name: "openid", description: "OpenID Connect scope" }
        - { name: "groups", description: "OIDC Groups scope" }
        - { name: "profile", description: "OIDC Profile scope" }
        - { name: "email", description: "OIDC Email scope" }

    - name: Get all client scopes
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/client-scopes"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        status_code: 200
        validate_certs: false  # Self-signed certificate during initial deployment
      register: all_scopes

    - name: Set scope IDs as facts
      ansible.builtin.set_fact:
        openid_scope_id: "{{ (all_scopes.json | selectattr('name', 'equalto', 'openid') | first).id }}"
        groups_scope_id: "{{ (all_scopes.json | selectattr('name', 'equalto', 'groups') | first).id }}"
        profile_scope_id: "{{ (all_scopes.json | selectattr('name', 'equalto', 'profile') | first).id }}"
        email_scope_id: "{{ (all_scopes.json | selectattr('name', 'equalto', 'email') | first).id }}"

    - name: Associate scopes with harbor client
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/clients/{{ harbor_client_uuid }}/default-client-scopes/{{ item }}"
        method: PUT
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        status_code: [204, 409]
        validate_certs: false  # Self-signed certificate during initial deployment
      loop:
        - "{{ openid_scope_id }}"
        - "{{ groups_scope_id }}"
        - "{{ profile_scope_id }}"
        - "{{ email_scope_id }}"

    - name: Create groups mapper for groups scope
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/client-scopes/{{ groups_scope_id }}/protocol-mappers/models"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "groups-mapper"
          protocol: "openid-connect"
          protocolMapper: "oidc-group-membership-mapper"
          config:
            full.path: "false"
            id.token.claim: "true"
            access.token.claim: "true"
            claim.name: "groups"
            userinfo.token.claim: "true"
        status_code: [201, 409]
        validate_certs: false  # Self-signed certificate during initial deployment

    - name: Create harbor-admins group
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/groups"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "{{ oidc_admin_group }}"
          attributes:
            description: ["Harbor Registry Administrators"]
        status_code: [201, 409]
        validate_certs: false  # Self-signed certificate during initial deployment
      register: group_creation

    # Get harbor-admins group for adding users
    - name: Get 'harbor-admins' group ID
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/groups"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        status_code: 200
        validate_certs: false  # Self-signed certificate during initial deployment
      register: groups_response
      no_log: false

    # Add auth realm user to harbor-admins group
    - name: Get auth realm user info
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/users?username={{ auth_realm_username }}&exact=true"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        status_code: 200
        validate_certs: false  # Self-signed certificate during initial deployment
      register: auth_realm_user_response
      no_log: false

    - name: Add '{{ auth_realm_username }}' user to 'harbor-admins' group if it exists
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/users/{{ auth_realm_user_response.json[0].id }}/groups/{{ groups_response.json | selectattr('name', 'equalto', oidc_admin_group) | map(attribute='id') | first }}"
        method: PUT
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
          Content-Type: "application/json"
        status_code: 204
        validate_certs: false  # Self-signed certificate during initial deployment
      when:
        - auth_realm_user_response.json | length > 0
        - groups_response.json | selectattr('name', 'equalto', oidc_admin_group) | list | length > 0

    - name: Get client secret for harbor
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/clients/{{ harbor_client_uuid }}/client-secret"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        status_code: 200
        validate_certs: false  # Self-signed certificate during initial deployment
      register: harbor_client_secret
      no_log: true

    - name: Save client secret to file
      ansible.builtin.copy:
        content: "{{ harbor_client_secret.json.value }}"
        dest: /tmp/harbor_oidc_secret
        mode: '0600'
      no_log: true

    ########################################################################
    # 2. Harbor Deployment
    ########################################################################

    - name: Ensure Harbor namespace exists
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} apply -f -"
        stdin: |
          apiVersion: v1
          kind: Namespace
          metadata:
            name: {{ harbor_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: namespace_result
      changed_when: "'created' in namespace_result.stdout or 'configured' in namespace_result.stdout"

    - name: Check if wildcard certificate exists in default namespace
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} get secret {{ domain_name.replace('.', '-') }}-tls -n default -o json"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: wildcard_cert
      changed_when: false
      failed_when: wildcard_cert.rc != 0

    - name: Parse wildcard certificate JSON
      ansible.builtin.set_fact:
        wildcard_cert_json: "{{ wildcard_cert.stdout | from_json }}"

    - name: Check if TLS secret already exists in harbor namespace
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} get secret harbor-tls-secret -n {{ harbor_namespace }} -o json"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: existing_cert_check
      changed_when: false
      failed_when: false

    - name: Delete existing TLS secret if it exists
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} delete secret harbor-tls-secret -n {{ harbor_namespace }}"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      when: existing_cert_check.rc == 0
      changed_when: true

    - name: Copy wildcard certificate from default namespace
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} apply -f -"
        stdin: "{{ lookup('template', 'templates/harbor-tls-secret.yaml.j2') }}"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: copy_cert
      changed_when: "'created' in copy_cert.stdout or 'configured' in copy_cert.stdout"

    - name: Check if TLS secret was created
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} get secret harbor-tls-secret -n {{ harbor_namespace }} -o json"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: cert_check
      changed_when: false

    - name: Parse TLS secret JSON
      ansible.builtin.set_fact:
        cert_check_json: "{{ cert_check.stdout | from_json }}"

    - name: Verify TLS secret exists
      ansible.builtin.assert:
        that:
          - cert_check_json is defined
          - cert_check_json.metadata is defined
          - cert_check_json.metadata.name == 'harbor-tls-secret'
        fail_msg: "Failed to copy wildcard certificate"

    - name: Add Harbor Helm repository
      ansible.builtin.command:
        cmd: "{{ helm_bin }} repo add harbor https://helm.goharbor.io"
      register: helm_repo_add
      changed_when: "'already exists' not in helm_repo_add.stderr"
      failed_when: helm_repo_add.rc != 0 and 'already exists' not in helm_repo_add.stderr

    - name: Update Helm repositories
      ansible.builtin.command: "{{ helm_bin }} repo update"
      changed_when: false

    - name: Create Harbor values file
      ansible.builtin.copy:
        dest: "{{ harbor_values }}"
        content: |
          expose:
            type: ingress
            ingress:
              hosts:
                core: "{{ harbor_registry }}"
              annotations:
                kubernetes.io/ingress.class: "{{ primary_ingress_class }}"
                nginx.ingress.kubernetes.io/proxy-body-size: "0"
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
                nginx.ingress.kubernetes.io/proxy-connect-timeout: "3600"
                nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
                nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
            tls:
              enabled: true
              certSource: secret
              secret:
                secretName: harbor-tls-secret

          externalURL: https://{{ harbor_registry }}

          # Use custom-built tk-harbor images (built on control plane)
          # Harbor v2.14.0 doesn't provide official ARM64 images
          # All components pinned to control plane where images are built
          imagePullPolicy: Never

          core:
            image:
              repository: tk-harbor-harbor-core
              tag: v2.14.0
            nodeSelector:
              kubernetes.io/hostname: {{ control_plane_hostname }}

          portal:
            image:
              repository: tk-harbor-harbor-portal
              tag: v2.14.0
            nodeSelector:
              kubernetes.io/hostname: {{ control_plane_hostname }}

          jobservice:
            image:
              repository: tk-harbor-harbor-jobservice
              tag: v2.14.0
            nodeSelector:
              kubernetes.io/hostname: {{ control_plane_hostname }}

          registry:
            registry:
              image:
                repository: tk-harbor-registry-photon
                tag: v2.14.0
            controller:
              image:
                repository: tk-harbor-harbor-registryctl
                tag: v2.14.0
            nodeSelector:
              kubernetes.io/hostname: {{ control_plane_hostname }}

          database:
            internal:
              image:
                repository: tk-harbor-harbor-db
                tag: v2.14.0
              nodeSelector:
                kubernetes.io/hostname: {{ control_plane_hostname }}

          redis:
            internal:
              image:
                repository: tk-harbor-redis-photon
                tag: v2.14.0
              nodeSelector:
                kubernetes.io/hostname: {{ control_plane_hostname }}

          trivy:
            image:
              repository: tk-harbor-trivy-adapter-photon
              tag: v2.14.0
            nodeSelector:
              kubernetes.io/hostname: {{ control_plane_hostname }}

          persistence:
            enabled: true
            resourcePolicy: "keep"
            persistentVolumeClaim:
              registry:
                storageClass: "k8s-hostpath"
                accessMode: ReadWriteOnce
                size: 50Gi
              jobservice:
                jobLog:
                  storageClass: "k8s-hostpath"
                  accessMode: ReadWriteOnce
                  size: 5Gi
              database:
                storageClass: "k8s-hostpath"
                accessMode: ReadWriteOnce
                size: 10Gi
              redis:
                storageClass: "k8s-hostpath"
                accessMode: ReadWriteOnce
                size: 2Gi
              trivy:
                storageClass: "k8s-hostpath"
                accessMode: ReadWriteOnce
                size: 10Gi

    - name: Deploy Harbor using Helm
      ansible.builtin.command:
        cmd: >
          {{ helm_bin }} upgrade --install {{ harbor_release }}
          harbor/harbor
          --namespace {{ harbor_namespace }}
          --create-namespace=false
          --values {{ harbor_values }}
          --wait
          --timeout 600s
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: helm_install
      changed_when: "'deployed' in helm_install.stdout or 'upgraded' in helm_install.stdout"

    - name: Wait for Harbor pods readiness
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} get pods -n {{ harbor_namespace }} -l app.kubernetes.io/instance={{ harbor_release }} -o json"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: harbor_pods
      until: >
        (harbor_pods.stdout | from_json).items | length > 0 and
        ((harbor_pods.stdout | from_json).items | map(attribute='status.phase') | list | unique == ['Running'])
      retries: 30
      delay: 10
      changed_when: false

    - name: Get Harbor admin password
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} get secret harbor-core -n {{ harbor_namespace }} -o json"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: harbor_secret
      until: (harbor_secret.stdout | from_json) is defined
      retries: 30
      delay: 10
      changed_when: false

    - name: Parse Harbor secret JSON
      ansible.builtin.set_fact:
        harbor_secret_json: "{{ harbor_secret.stdout | from_json }}"

    - name: Get Harbor generated password
      ansible.builtin.set_fact:
        harbor_generated_password: "{{ harbor_secret_json.data.HARBOR_ADMIN_PASSWORD | b64decode }}"
      when:
        - harbor_secret_json is defined
        - harbor_secret_json.data is defined
        - harbor_secret_json.data.HARBOR_ADMIN_PASSWORD is defined

    - name: Fail if Harbor password secret not found
      ansible.builtin.fail:
        msg: "Harbor admin password secret not found. Harbor may not be properly deployed."
      when:
        - harbor_secret_json is not defined or harbor_secret_json.data is not defined or harbor_secret_json.data.HARBOR_ADMIN_PASSWORD is not defined

    - name: Read OIDC secret - Checking if file exists first
      ansible.builtin.stat:
        path: /tmp/harbor_oidc_secret
      register: secret_file_stat

    - name: Fail if OIDC secret file doesn't exist
      ansible.builtin.fail:
        msg: "OIDC client secret file not found at /tmp/harbor_oidc_secret. Keycloak client configuration may have failed."
      when: not secret_file_stat.stat.exists

    - name: Read OIDC secret
      ansible.builtin.slurp:
        src: /tmp/harbor_oidc_secret
      register: oidc_secret_file
      when: secret_file_stat.stat.exists

    - name: Set OIDC client secret fact
      ansible.builtin.set_fact:
        oidc_client_secret: "{{ oidc_secret_file.content | b64decode }}"
      when: oidc_secret_file is defined

    - name: Check if admin password is already set to our standard
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/configurations"
        method: GET
        headers:
          Authorization: "Basic {{ (harbor_admin_user + ':' + admin_password) | b64encode }}"
          Accept: "application/json"
        validate_certs: false
        status_code: [200, 401]
        follow_redirects: none
      register: harbor_api_standard_pass

    - name: Wait for Harbor API readiness with generated password
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/systeminfo"
        method: GET
        headers:
          Authorization: "Basic {{ (harbor_admin_user + ':' + harbor_generated_password) | b64encode }}"
        validate_certs: false
        status_code: 200
      register: harbor_api
      until: harbor_api.status == 200
      retries: 30
      delay: 10
      when: harbor_api_standard_pass.status == 401

    - name: Change Harbor admin password to our standard
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/users/1/password"
        method: PUT
        headers:
          Authorization: "Basic {{ (harbor_admin_user + ':' + harbor_generated_password) | b64encode }}"
          Content-Type: "application/json"
        body_format: json
        body:
          old_password: "{{ harbor_generated_password }}"
          new_password: "{{ admin_password }}"
        validate_certs: false
        status_code: 200
      when: harbor_api_standard_pass.status == 401

    # Verify Harbor admin password is now set correctly
    - name: Verify Harbor API access with admin password
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/systeminfo"
        method: GET
        headers:
          Authorization: "Basic {{ (harbor_admin_user + ':' + admin_password) | b64encode }}"
        validate_certs: false
        status_code: 200
      register: harbor_api_verify
      retries: 3
      delay: 5
      until: harbor_api_verify.status == 200

    # Refresh Keycloak token before verifying group
    - name: Refresh Keycloak admin token
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/realms/master/protocol/openid-connect/token"
        method: POST
        body_format: form-urlencoded
        body:
          username: "{{ admin_username }}"
          password: "{{ admin_password }}"
          grant_type: password
          client_id: "admin-cli"
        validate_certs: false
        status_code: [200, 201]
      register: keycloak_token_refresh
      no_log: true

    - name: Update token variable
      ansible.builtin.set_fact:
        keycloak_token: "{{ keycloak_token_refresh }}"

    - name: Verify that harbor-admins group exists in Keycloak
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/groups?search={{ oidc_admin_group }}"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        status_code: 200
        validate_certs: false  # Self-signed certificate during initial deployment
      register: verify_admin_group

    - name: Verify admin group exists
      ansible.builtin.assert:
        that: verify_admin_group.json | selectattr('name', 'equalto', oidc_admin_group) | list | length > 0
        fail_msg: "The harbor-admins group does not exist in Keycloak! OIDC admin privileges will not work."
        success_msg: "harbor-admins group exists in Keycloak"

    # This follows exactly the approach from the original playbook
    - name: Configure Harbor OIDC authentication
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/configurations"
        method: PUT
        headers:
          Authorization: "Basic {{ (harbor_admin_user + ':' + admin_password) | b64encode }}"
          Content-Type: "application/json"
        body_format: json
        body:
          auth_mode: oidc_auth
          oidc_endpoint: "{{ keycloak_url }}/realms/{{ keycloak_realm }}"
          oidc_client_id: "{{ oidc_client_id }}"
          oidc_client_secret: "{{ oidc_client_secret }}"
          oidc_scope: "{{ oidc_scopes }}"
          oidc_auto_onboard: true
          oidc_groups_claim: "{{ oidc_group_claim }}"
          oidc_admin_group: "{{ oidc_admin_group }}"
        validate_certs: false
        status_code: [200, 201]
      register: oidc_config

    # Copy the Let's Encrypt certificate to Harbor's trusted store
    - name: Extract Let's Encrypt R11 certificate from default/{{ domain_name.replace('.', '-') }}-tls
      ansible.builtin.shell: |
        {{ kubectl_bin }} get secret {{ domain_name.replace('.', '-') }}-tls -n default -o jsonpath='{.data.tls\.crt}' | base64 -d > /tmp/{{ domain_name.replace('.', '-') }}.crt
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      changed_when: true

    - name: Get the intermediate certificate chain for Let's Encrypt
      ansible.builtin.shell: |
        openssl s_client -showcerts -connect auth.{{ domain_name }}:443 </dev/null 2>/dev/null | \
        awk '/BEGIN CERTIFICATE/,/END CERTIFICATE/{ if(!/BEGIN CERTIFICATE/ && !/END CERTIFICATE/) print }' > /tmp/lets-encrypt-chain.pem
      args:
        executable: /bin/bash
      changed_when: true

    - name: Read certificate files
      ansible.builtin.slurp:
        src: "/tmp/{{ domain_name.replace('.', '-') }}.crt"
      register: cert_content

    - name: Read chain files
      ansible.builtin.slurp:
        src: "/tmp/lets-encrypt-chain.pem"
      register: chain_content

    - name: Create a ConfigMap with the certificates
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} apply -f -"
        stdin: |
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: trusted-ca-bundle
            namespace: {{ harbor_namespace }}
          data:
            ca-certificates.crt: {{ cert_content.content | b64decode | to_json }}
            lets-encrypt-chain.pem: {{ chain_content.content | b64decode | to_json }}
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: configmap_result
      changed_when: "'created' in configmap_result.stdout or 'configured' in configmap_result.stdout"

    - name: Patch Harbor core deployment to mount the ConfigMap
      ansible.builtin.shell: |
        {{ kubectl_bin }} patch deployment harbor-core -n {{ harbor_namespace }} --type=json -p='[
          {"op":"add", "path":"/spec/template/spec/volumes/-", "value":{"name":"trusted-ca-bundle","configMap":{"name":"trusted-ca-bundle"}}},
          {"op":"add", "path":"/spec/template/spec/containers/0/volumeMounts/-", "value":{"name":"trusted-ca-bundle","mountPath":"/usr/local/share/ca-certificates","readOnly":true}}
        ]'
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      changed_when: true
      ignore_errors: true  # In case the volume already exists

    - name: Restart Harbor core to pick up certificate changes
      ansible.builtin.shell: |
        {{ kubectl_bin }} rollout restart deployment harbor-core -n {{ harbor_namespace }}
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      changed_when: true

    - name: Wait for Harbor core to be ready
      ansible.builtin.shell: |
        {{ kubectl_bin }} rollout status deployment harbor-core -n {{ harbor_namespace }} --timeout=120s
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      changed_when: false

    - name: Verify Harbor authentication configuration
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/systeminfo"
        method: GET
        headers:
          Authorization: "Basic {{ (harbor_admin_user + ':' + admin_password) | b64encode }}"
        validate_certs: false
        status_code: 200
      register: final_config
      until: final_config.status == 200
      retries: 10
      delay: 10

    - name: Verify auth mode is OIDC
      ansible.builtin.assert:
        that:
          - final_config.json.auth_mode == 'oidc_auth'
        fail_msg: "Harbor auth mode is not OIDC: {{ final_config.json.auth_mode | default('unknown') }}"
        success_msg: "Harbor is configured for OIDC authentication"

    - name: Verify OIDC configuration
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/configurations"
        method: GET
        headers:
          Authorization: "Basic {{ (harbor_admin_user + ':' + admin_password) | b64encode }}"
        validate_certs: false
        status_code: 200
      register: harbor_config
      until: harbor_config.status == 200
      retries: 5
      delay: 5

    - name: Display OIDC configuration
      ansible.builtin.debug:
        msg:
          - "Auth Mode: {{ harbor_config.json.auth_mode.value }}"
          - "OIDC Admin Group: {{ harbor_config.json.oidc_admin_group.value }}"
          - "OIDC Auto Onboard: {{ harbor_config.json.oidc_auto_onboard.value }}"
          - "OIDC Groups Claim: {{ harbor_config.json.oidc_groups_claim.value }}"

    - name: Check if local-registry-hosting ConfigMap exists
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} get configmap local-registry-hosting -n kube-public -o json"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: configmap_check
      changed_when: false
      failed_when: false

    - name: Create or update local-registry-hosting ConfigMap
      ansible.builtin.command:
        cmd: "{{ kubectl_bin }} apply -f -"
        stdin: |
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: local-registry-hosting
            namespace: kube-public
          data:
            localRegistryHosting.v1: |
              help: "https://documentation.ubuntu.com/canonical-kubernetes/latest/snap/howto/registry/"
              host: "{{ harbor_registry }}"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: configmap_create
      changed_when: "'created' in configmap_create.stdout or 'configured' in configmap_create.stdout"

    - name: Restart k8s to apply registry changes
      ansible.builtin.shell: |
        k8s stop && k8s start
      become: true
      when: configmap_check.rc != 0

    - name: Wait for k8s to be ready
      ansible.builtin.shell: |
        k8s status --wait-ready
      become: true
      register: k8s_status
      retries: 30
      delay: 10
      until: k8s_status.rc == 0
      when: configmap_check.rc != 0

    - name: Display deployment status
      ansible.builtin.debug:
        msg:
          - "Harbor deployed successfully"
          - "Registry URL: https://{{ harbor_registry }}"
          - "Authentication: OIDC via Keycloak"
          - "Admin group: {{ oidc_admin_group }}"
          - "Harbor admin password set to standard (user: admin)"
          - "SSO user '{{ auth_realm_username }}' added to harbor-admins group"
          - "Default registry configured: {{ harbor_registry }}"
          - "Registry ConfigMap: {{ 'Created' if configmap_check.rc != 0 else 'Already exists' }}"
