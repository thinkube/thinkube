# Copyright 2025 Alejandro Martínez Corriá and the Thinkube contributors
# SPDX-License-Identifier: Apache-2.0

---
# Deploy Ingress Controllers
#
# This playbook deploys two separate ingress controllers via Helm:
#
#     1. Primary Ingress Controller (for general services)
#        - Namespace: ingress
#        - Release Name: primary-ingress
#        - IngressClass: "nginx" (set as default)
#        - The controller is deployed as a Deployment whose service name is expected to be:
#          primary-ingress-ingress-nginx-controller
#
#     2. Secondary Ingress Controller (for specialized workloads)
#        - Namespace: ingress-kn
#        - Release Name: secondary-ingress
#        - IngressClass: "nginx-kn"
#
# Requirements:
#   - Canonical k8s-snap is installed on the target host.
#   - MetalLB is already enabled by k8s-snap installation.
#   - acme-certificates must be deployed first to create the wildcard certificate
#
# This playbook also copies the wildcard certificate to the ingress namespaces after the controllers
# are deployed, to ensure that the namespaces exist before certificates are copied.
#
# Usage:
#   Run from ansible root directory:
#   ansible-playbook -i inventory/inventory.yaml ansible/40_thinkube/core/infrastructure/ingress/10_deploy.yaml

- name: Deploy Primary Ingress Controller
  hosts: k8s_control_plane
  become: false
  vars:
    primary_release: "primary-ingress"
    primary_controller_class: "k8s.io/primary-ingress-nginx"
    # Determine subnet prefix based on network mode
    subnet_prefix: "{{ zerotier_subnet_prefix if network_mode == 'overlay' else network_cidr.split('/')[0] | regex_replace('\\.[0-9]+$', '.') }}"
    # Build the required variables from inventory
    primary_ingress_ip: "{{ subnet_prefix }}{{ primary_ingress_ip_octet }}"
    # kubectl_bin, helm_bin, kubeconfig inherited from group_vars

  pre_tasks:
    - name: Add ingress-nginx Helm repository
      ansible.builtin.command: "{{ helm_bin }} repo add ingress-nginx https://kubernetes.github.io/ingress-nginx --force-update"
      changed_when: false

    - name: Update Helm repositories
      ansible.builtin.command: "{{ helm_bin }} repo update"
      changed_when: false

  tasks:
    - name: Verify MetalLB is installed
      ansible.builtin.command: "{{ kubectl_bin }} get namespace metallb-system"
      register: metallb_check
      failed_when: false
      changed_when: false
      environment:
        KUBECONFIG: "{{ kubeconfig }}"

    - name: Fail if MetalLB is not installed
      ansible.builtin.fail:
        msg: "MetalLB is not installed. Please deploy k8s-snap playbook first which installs MetalLB."
      when: metallb_check.rc != 0

    - name: Create primary ingress namespace if not exists
      ansible.builtin.shell: |
        {{ kubectl_bin }} create namespace {{ ingress_namespace }} --dry-run=client -o yaml | {{ kubectl_bin }} apply -f -
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: create_primary_ns
      changed_when: "'created' in create_primary_ns.stdout or 'configured' in create_primary_ns.stdout"

    # TCP services ConfigMap is created automatically by Helm chart when tcp values are provided

    - name: Create Helm values file for Primary Ingress
      ansible.builtin.copy:
        content: |
          controller:
            electionID: "primary-ingress-ingress-nginx-leader"
            ingressClass: "{{ primary_ingress_class }}"
            ingressClassResource:
              name: "{{ primary_ingress_class }}"
              enabled: true
              default: true
              controllerValue: "{{ primary_controller_class }}"
            watchIngressWithoutClass: false
            service:
              type: LoadBalancer
              loadBalancerIP: "{{ primary_ingress_ip }}"
              ports:
                http: 80
                https: 443
              targetPorts:
                http: http
                https: https
            publishService:
              enabled: true
              path: "{{ ingress_namespace }}/{{ primary_ingress_service }}"
            extraArgs:
              controller-class: "{{ primary_controller_class }}"
              default-ssl-certificate: "{{ ingress_namespace }}/{{ ingress_namespace }}-tls-secret"
            metrics:
              enabled: true
              port: 10254
              service:
                annotations:
                  prometheus.io/scrape: "true"
                  prometheus.io/port: "10254"
          tcp:
            5432: "postgres/postgresql-official:5432"
            2222: "gitea/gitea:22"
        dest: /tmp/primary-ingress-values.yaml
        mode: '0644'

    - name: Deploy Primary Ingress Controller via Helm
      ansible.builtin.shell: |
        {{ helm_bin }} upgrade --install {{ primary_release }} ingress-nginx/ingress-nginx \
          --namespace {{ ingress_namespace }} \
          --values /tmp/primary-ingress-values.yaml \
          --wait \
          --timeout 10m
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: helm_primary_deploy
      changed_when: "'has been upgraded' in helm_primary_deploy.stdout or 'has been installed' in helm_primary_deploy.stdout"

    - name: Get Primary Ingress Service Info
      ansible.builtin.shell: |
        {{ kubectl_bin }} get svc {{ primary_ingress_service }} -n {{ ingress_namespace }} -o json
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: svc_info_raw
      changed_when: false
      failed_when: false

    - name: Debug Primary Ingress Service Data
      ansible.builtin.debug:
        msg: "{{ svc_info_raw.stdout | from_json if svc_info_raw.rc == 0 else 'Service not found' }}"

    - name: Wait for Primary Ingress Service External IP Assignment
      ansible.builtin.shell: |
        {{ kubectl_bin }} get svc {{ primary_ingress_service }} -n {{ ingress_namespace }} -o json
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: svc_check
      until: >
        svc_check.rc == 0 and
        (svc_check.stdout | from_json).status.loadBalancer.ingress is defined and
        (svc_check.stdout | from_json).status.loadBalancer.ingress | length > 0 and
        (svc_check.stdout | from_json).status.loadBalancer.ingress[0].ip == primary_ingress_ip
      retries: 20
      delay: 3
      changed_when: false

    - name: Delete extra IngressClass 'public' (if exists) to avoid conflicts
      ansible.builtin.shell: "{{ kubectl_bin }} delete ingressclass public"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      ignore_errors: yes
      changed_when: false

    - name: Patch IngressClass '{{ primary_ingress_class }}' to be default
      ansible.builtin.shell: >
        {{ kubectl_bin }} patch ingressclass {{ primary_ingress_class }} --type=json -p='[{"op":"add","path":"/metadata/annotations","value":{"ingressclass.kubernetes.io/is-default-class":"true"}}]'
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      ignore_errors: yes
      changed_when: false

    - name: Patch primary ingress controller to publish its service IP
      ansible.builtin.shell: >
        {{ kubectl_bin }} patch deployment {{ primary_ingress_service }} -n {{ ingress_namespace }} --type='json'
        -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--publish-service={{ ingress_namespace }}/{{ primary_ingress_service }}"}]'
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: patch_primary_ds
      changed_when: "'patched' in patch_primary_ds.stdout"

    - name: Restart primary ingress controller pods to pick up new args
      ansible.builtin.shell: "{{ kubectl_bin }} rollout restart deployment {{ primary_ingress_service }} -n {{ ingress_namespace }}"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      changed_when: true

- name: Deploy Secondary Ingress Controller via Helm (for specialized workloads)
  hosts: k8s_control_plane
  become: false
  vars:
    secondary_release: "secondary-ingress"
    secondary_controller_class: "k8s.io/secondary-ingress-nginx"
    # Use the same subnet prefix as primary ingress
    subnet_prefix: "{{ zerotier_subnet_prefix if network_mode == 'overlay' else network_cidr.split('/')[0] | regex_replace('\\.[0-9]+$', '.') }}"
    secondary_ingress_ip: "{{ subnet_prefix }}{{ secondary_ingress_ip_octet }}"
    # kubectl_bin, helm_bin, kubeconfig inherited from group_vars
  tasks:
    - name: Create secondary ingress namespace if not exists
      ansible.builtin.shell: |
        {{ kubectl_bin }} create namespace {{ ingress_kn_namespace }} --dry-run=client -o yaml | {{ kubectl_bin }} apply -f -
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: create_secondary_ns
      changed_when: "'created' in create_secondary_ns.stdout or 'configured' in create_secondary_ns.stdout"

    - name: Create Helm values file for Secondary Ingress
      ansible.builtin.copy:
        content: |
          controller:
            electionID: "secondary-ingress-ingress-nginx-leader"
            ingressClass: "{{ secondary_ingress_class }}"
            ingressClassResource:
              name: "{{ secondary_ingress_class }}"
              enabled: true
              default: false
              controllerValue: "{{ secondary_controller_class }}"
            watchIngressWithoutClass: false
            service:
              type: LoadBalancer
              loadBalancerIP: "{{ secondary_ingress_ip }}"
            publishService:
              enabled: true
              path: "{{ ingress_kn_namespace }}/{{ secondary_release }}-ingress-nginx-controller"
            extraArgs:
              controller-class: "{{ secondary_controller_class }}"
              default-ssl-certificate: "{{ ingress_kn_namespace }}/{{ ingress_kn_namespace }}-tls-secret"
            metrics:
              enabled: true
              port: 10254
              service:
                annotations:
                  prometheus.io/scrape: "true"
                  prometheus.io/port: "10254"
        dest: /tmp/secondary-ingress-values.yaml
        mode: '0644'

    - name: Deploy Secondary Ingress Controller via Helm
      ansible.builtin.shell: |
        {{ helm_bin }} upgrade --install {{ secondary_release }} ingress-nginx/ingress-nginx \
          --namespace {{ ingress_kn_namespace }} \
          --values /tmp/secondary-ingress-values.yaml \
          --wait \
          --timeout 10m \
          --force
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: helm_secondary_deploy
      changed_when: "'has been upgraded' in helm_secondary_deploy.stdout or 'has been installed' in helm_secondary_deploy.stdout"

    - name: Get Secondary Ingress Service Info
      ansible.builtin.shell: |
        {{ kubectl_bin }} get svc {{ secondary_release }}-ingress-nginx-controller -n {{ ingress_kn_namespace }} -o json
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: svc_info_kn_raw
      changed_when: false
      failed_when: false

    - name: Debug Secondary Ingress Service Data
      ansible.builtin.debug:
        msg: "{{ svc_info_kn_raw.stdout | from_json if svc_info_kn_raw.rc == 0 else 'Service not found' }}"

    - name: Wait for Secondary Ingress Service External IP Assignment
      ansible.builtin.shell: |
        {{ kubectl_bin }} get svc {{ secondary_release }}-ingress-nginx-controller -n {{ ingress_kn_namespace }} -o json
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: svc_check_kn
      until: >
        svc_check_kn.rc == 0 and
        (svc_check_kn.stdout | from_json).status.loadBalancer.ingress is defined and
        (svc_check_kn.stdout | from_json).status.loadBalancer.ingress | length > 0 and
        (svc_check_kn.stdout | from_json).status.loadBalancer.ingress[0].ip == secondary_ingress_ip
      retries: 20
      delay: 3
      changed_when: false

    - name: Patch secondary ingress controller to publish its service IP
      ansible.builtin.shell: >
        {{ kubectl_bin }} patch deployment {{ secondary_release }}-ingress-nginx-controller -n {{ ingress_kn_namespace }} --type='json'
        -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--publish-service={{ ingress_kn_namespace }}/{{ secondary_release }}-ingress-nginx-controller"}]'
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: patch_secondary_ds
      changed_when: "'patched' in patch_secondary_ds.stdout"

    - name: Restart secondary ingress controller pods to pick up new args
      ansible.builtin.shell: "{{ kubectl_bin }} rollout restart deployment {{ secondary_release }}-ingress-nginx-controller -n {{ ingress_kn_namespace }}"
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      changed_when: true

- name: Copy wildcard certificates to ingress namespaces
  hosts: k8s_control_plane
  become: false
  # kubectl_bin and kubeconfig inherited from group_vars
  tasks:
    - name: Get wildcard certificate from default namespace
      ansible.builtin.shell: |
        {{ kubectl_bin }} get secret {{ domain_name | replace('.', '-') }}-tls -n default -o json
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: wildcard_cert_raw
      failed_when: wildcard_cert_raw.rc != 0
      changed_when: false

    - name: Parse wildcard certificate
      ansible.builtin.set_fact:
        wildcard_cert_data: "{{ wildcard_cert_raw.stdout | from_json }}"

    - name: Create certificate secret YAML for primary ingress namespace
      ansible.builtin.copy:
        content: |
          apiVersion: v1
          kind: Secret
          metadata:
            name: {{ ingress_namespace }}-tls-secret
            namespace: {{ ingress_namespace }}
            labels:
              app.kubernetes.io/name: "wildcard-certificate"
              app.kubernetes.io/instance: "ingress"
          type: kubernetes.io/tls
          data:
            tls.crt: {{ wildcard_cert_data.data['tls.crt'] }}
            tls.key: {{ wildcard_cert_data.data['tls.key'] }}
        dest: /tmp/primary-ingress-tls-secret.yaml
        mode: '0644'

    - name: Copy wildcard certificate to primary ingress namespace
      ansible.builtin.shell: |
        {{ kubectl_bin }} apply -f /tmp/primary-ingress-tls-secret.yaml
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: primary_cert_copy
      changed_when: "'created' in primary_cert_copy.stdout or 'configured' in primary_cert_copy.stdout"
      tags:
        - certificate

    - name: Create certificate secret YAML for secondary ingress namespace
      ansible.builtin.copy:
        content: |
          apiVersion: v1
          kind: Secret
          metadata:
            name: {{ ingress_kn_namespace }}-tls-secret
            namespace: {{ ingress_kn_namespace }}
            labels:
              app.kubernetes.io/name: "wildcard-certificate"
              app.kubernetes.io/instance: "ingress-kn"
          type: kubernetes.io/tls
          data:
            tls.crt: {{ wildcard_cert_data.data['tls.crt'] }}
            tls.key: {{ wildcard_cert_data.data['tls.key'] }}
        dest: /tmp/secondary-ingress-tls-secret.yaml
        mode: '0644'

    - name: Copy wildcard certificate to secondary ingress namespace
      ansible.builtin.shell: |
        {{ kubectl_bin }} apply -f /tmp/secondary-ingress-tls-secret.yaml
      environment:
        KUBECONFIG: "{{ kubeconfig }}"
      register: secondary_cert_copy
      changed_when: "'created' in secondary_cert_copy.stdout or 'configured' in secondary_cert_copy.stdout"
      tags:
        - certificate

    - name: Display certificate status
      ansible.builtin.debug:
        msg:
          - "Wildcard certificates successfully copied to ingress namespaces"
          - "Primary ingress: {{ ingress_namespace }}/{{ ingress_namespace }}-tls-secret"
          - "Secondary ingress: {{ ingress_kn_namespace }}/{{ ingress_kn_namespace }}-tls-secret"
      tags:
        - info
