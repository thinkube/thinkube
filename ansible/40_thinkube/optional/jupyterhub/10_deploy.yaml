---
# ansible/40_thinkube/optional/jupyterhub/10_deploy.yaml
# Description:
#   Deploys JupyterHub with dynamic image discovery from thinkube-control
#   Fast deployment (2 minutes) - no image building
#
# Requirements:
#   - MicroK8s must be installed and running
#   - Keycloak must be deployed (mandatory, no fallback)
#   - SeaweedFS must be deployed (mandatory, no fallback)
#   - thinkube-control must be running (mandatory, no fallback)
#   - Harbor registry must be accessible
#
# Usage:
#   cd ~/thinkube
#   ./scripts/run_ansible.sh ansible/40_thinkube/optional/jupyterhub/10_deploy.yaml
#
# Variables from inventory:
#   - domain_name: Base domain for the installation
#   - harbor_registry: Harbor registry URL
#   - admin_username: Administrator username
#   - jupyterhub_client_secret: OAuth client secret for Keycloak
#   - keycloak_realm: Keycloak realm name
#
# Dependencies:
#   - CORE-002 (Harbor) must be complete
#   - CORE-003 (Keycloak) must be complete
#   - CORE-004 (SeaweedFS) must be complete
#   - thinkube-control must be deployed
#
# ðŸ¤– AI-assisted

- name: Deploy JupyterHub with Dynamic Image Discovery
  hosts: microk8s_control_plane
  gather_facts: true
  vars:
    jupyterhub_namespace: jupyterhub
    jupyterhub_version: "3.3.8"
    kubeconfig: /var/snap/microk8s/current/credentials/client.config
    helm_repo_name: jupyterhub
    helm_repo_url: https://hub.jupyter.org/helm-chart/

  tasks:
    # Step 1: Verify all dependencies are available (NO FALLBACKS)
    - name: Verify Keycloak is running
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig }}"
        api_version: apps/v1
        kind: Deployment
        namespace: keycloak
        name: keycloak
      register: keycloak_status
      failed_when: keycloak_status.resources | length == 0 or keycloak_status.resources[0].status.availableReplicas | default(0) == 0

    - name: Verify SeaweedFS is running
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig }}"
        api_version: apps/v1
        kind: StatefulSet
        namespace: seaweedfs
        name: seaweedfs-master
      register: seaweedfs_status
      failed_when: seaweedfs_status.resources | length == 0 or seaweedfs_status.resources[0].status.readyReplicas | default(0) == 0

    - name: Verify thinkube-control API is accessible
      ansible.builtin.uri:
        url: "http://{{ ansible_default_ipv4.address }}:30080/health"
        method: GET
        timeout: 10
      register: thinkube_control_health
      failed_when: thinkube_control_health.status != 200

    - name: Verify Harbor is accessible
      ansible.builtin.uri:
        url: "https://{{ harbor_registry }}/api/v2.0/health"
        method: GET
        validate_certs: false
        timeout: 10
      register: harbor_health
      failed_when: harbor_health.status != 200

    # Step 2: Create namespace
    - name: Create JupyterHub namespace
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        name: "{{ jupyterhub_namespace }}"
        api_version: v1
        kind: Namespace
        state: present

    # Step 3: Create SeaweedFS volumes for notebooks
    - name: Create SeaweedFS PVC for notebooks
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: jupyter-notebooks-pvc
            namespace: "{{ jupyterhub_namespace }}"
          spec:
            accessModes:
              - ReadWriteMany
            storageClassName: seaweedfs-storage
            resources:
              requests:
                storage: 100Gi

    - name: Create SeaweedFS PVC for datasets
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: jupyter-datasets-pvc
            namespace: "{{ jupyterhub_namespace }}"
          spec:
            accessModes:
              - ReadWriteMany
            storageClassName: seaweedfs-storage
            resources:
              requests:
                storage: 500Gi

    - name: Create SeaweedFS PVC for models
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: jupyter-models-pvc
            namespace: "{{ jupyterhub_namespace }}"
          spec:
            accessModes:
              - ReadWriteMany
            storageClassName: seaweedfs-storage
            resources:
              requests:
                storage: 200Gi

    # Step 4: Get wildcard certificate from default namespace
    - name: Get wildcard certificate from default namespace
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig }}"
        api_version: v1
        kind: Secret
        namespace: default
        name: thinkube-com-tls
      register: wildcard_cert
      failed_when: wildcard_cert.resources | length == 0

    - name: Copy wildcard certificate to JupyterHub namespace
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: jupyterhub-tls-secret
            namespace: "{{ jupyterhub_namespace }}"
          type: kubernetes.io/tls
          data:
            tls.crt: "{{ wildcard_cert.resources[0].data['tls.crt'] }}"
            tls.key: "{{ wildcard_cert.resources[0].data['tls.key'] }}"

    # Step 5: Add JupyterHub Helm repository
    - name: Add JupyterHub Helm repository
      kubernetes.core.helm_repository:
        name: "{{ helm_repo_name }}"
        repo_url: "{{ helm_repo_url }}"
        state: present

    # Step 6: Create values file from template
    - name: Create temporary directory for JupyterHub configuration
      ansible.builtin.tempfile:
        state: directory
        suffix: jupyterhub
      register: temp_dir

    - name: Template JupyterHub values file
      ansible.builtin.template:
        src: jupyterhub-values.yaml.j2
        dest: "{{ temp_dir.path }}/values.yaml"
        mode: '0644'

    # Step 7: Deploy JupyterHub using Helm
    - name: Deploy JupyterHub
      kubernetes.core.helm:
        name: jupyterhub
        chart_ref: "{{ helm_repo_name }}/jupyterhub"
        release_namespace: "{{ jupyterhub_namespace }}"
        create_namespace: false
        kubeconfig: "{{ kubeconfig }}"
        values_files:
          - "{{ temp_dir.path }}/values.yaml"
        wait: true
        wait_timeout: 10m
        state: present
        chart_version: "{{ jupyterhub_version }}"

    # Step 8: Create Ingress for JupyterHub
    - name: Create JupyterHub Ingress
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: jupyterhub-ingress
            namespace: "{{ jupyterhub_namespace }}"
            annotations:
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/proxy-body-size: "0"
              nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
              nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
              nginx.ingress.kubernetes.io/websocket-services: proxy-public
          spec:
            ingressClassName: nginx
            tls:
              - hosts:
                  - "jupyter.{{ domain_name }}"
                secretName: jupyterhub-tls-secret
            rules:
              - host: "jupyter.{{ domain_name }}"
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: proxy-public
                          port:
                            number: 80

    # Step 9: Wait for JupyterHub to be ready
    - name: Wait for JupyterHub hub pod to be ready
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig }}"
        api_version: v1
        kind: Pod
        namespace: "{{ jupyterhub_namespace }}"
        label_selectors:
          - app.kubernetes.io/name=jupyterhub
          - component=hub
        wait: true
        wait_condition:
          type: Ready
          status: "True"
        wait_timeout: 300

    - name: Wait for JupyterHub proxy pod to be ready
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig }}"
        api_version: v1
        kind: Pod
        namespace: "{{ jupyterhub_namespace }}"
        label_selectors:
          - app.kubernetes.io/name=jupyterhub
          - component=proxy
        wait: true
        wait_condition:
          type: Ready
          status: "True"
        wait_timeout: 300

    # Step 10: Clean up temporary directory
    - name: Clean up temporary directory
      ansible.builtin.file:
        path: "{{ temp_dir.path }}"
        state: absent

    # Step 11: Display access information
    - name: Display JupyterHub access information
      ansible.builtin.debug:
        msg:
          - "JupyterHub has been deployed successfully!"
          - "Access URL: https://jupyter.{{ domain_name }}"
          - "Authentication: Keycloak (username: {{ admin_username }})"
          - "Images will be discovered dynamically from thinkube-control"
          - "Deployment completed in < 2 minutes (no image building)"