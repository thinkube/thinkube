# Copyright 2025 Alejandro MartÃ­nez CorriÃ¡ and the Thinkube contributors
# SPDX-License-Identifier: Apache-2.0

---
# ansible/40_thinkube/optional/qdrant/10_deploy.yaml
# Description:
#   Deploy Qdrant vector database with authentication via OAuth2 Proxy
#
# Requirements:
#   - MicroK8s must be installed
#   - Keycloak instance running (CORE-006)
#   - TLS certificates available (CORE-004)
#   - ADMIN_PASSWORD environment variable set
#
# Usage:
#   cd ~/thinkube
#   ./scripts/run_ansible.sh ansible/40_thinkube/optional/qdrant/10_deploy.yaml
#
# Variables from inventory:
#   - domain_name: Base domain name
#   - qdrant_dashboard_hostname: Hostname for Qdrant dashboard
#   - qdrant_hostname: Hostname for Qdrant API
#   - kubeconfig: Path to kubeconfig file
#   - kubectl_bin: Path to kubectl binary
#   - helm_bin: Path to Helm binary
#   - keycloak_url: URL to Keycloak instance
#   - keycloak_hostname: Hostname for Keycloak
#   - keycloak_realm: Keycloak realm name
#   - admin_username: Admin username for Keycloak
#   - primary_ingress_class: Primary ingress class name
#   - primary_ingress_ip: Primary ingress IP address
#
# Dependencies:
#   - CORE-004: SSL/TLS Certificates must be configured
#   - CORE-006: Keycloak must be deployed
#
# ðŸ¤– [AI-assisted]

- name: Deploy Qdrant with OAuth2 Proxy and Valkey
  hosts: microk8s_control_plane
  gather_facts: true
  
  vars:
    # Common settings - specific to this deployment
    k8s_namespace: "{{ qdrant_namespace }}"
    qdrant_dashboard_host: "{{ qdrant_dashboard_hostname }}"
    cookie_domain: ".{{ domain_name }}"

    # TLS settings
    tls_secret_name: "qdrant-tls-secret"

    # Valkey settings - replaces Redis for licensing compliance
    valkey_namespace: "{{ k8s_namespace }}"
    valkey_kubeconfig: "{{ kubeconfig }}"

    # Keycloak settings for OAuth2 Proxy integration
    keycloak_admin_user: "{{ admin_username }}"
    keycloak_admin_password: "{{ lookup('env','ADMIN_PASSWORD') }}"
    # OAuth2 proxy role expects keycloak_admin_username
    keycloak_admin_username: "{{ admin_username }}"

    # OAuth2 Proxy settings - only the ones specific to this deployment
    oauth2_proxy_namespace: "{{ k8s_namespace }}"
    oauth2_proxy_name: "oauth2-proxy"
    oauth2_proxy_client_id: "qdrant-dashboard"
    oauth2_proxy_dashboard_host: "{{ qdrant_dashboard_host }}"
    oauth2_proxy_oidc_issuer_url: "{{ keycloak_url }}/realms/{{ keycloak_realm }}"
    oauth2_proxy_cookie_domain: "{{ cookie_domain }}"
    oauth2_proxy_ingress_host: "{{ qdrant_dashboard_host }}"
    oauth2_proxy_ingress_tls_secret_name: "{{ tls_secret_name }}"
    oauth2_proxy_redirect_url: "https://{{ qdrant_dashboard_host }}/oauth2/callback"
    oauth2_proxy_kubeconfig: "{{ kubeconfig }}"
    oauth2_proxy_helm_bin: "{{ helm_bin }}"
    oauth2_proxy_keycloak_debug: true

    # Valkey session configuration - replaces Redis
    oauth2_proxy_session_store_type: "redis"  # Valkey is Redis-compatible
    oauth2_proxy_redis_service: "ephemeral-valkey"  # Match the Valkey service name
    oauth2_proxy_ingress_enabled: true        # Create a separate /oauth2 ingress
    oauth2_proxy_cookie_samesite: "none"      # Good for various dashboards

  tasks:
    ###########################################################################
    # Step 1: Create Namespace and TLS Secret
    ###########################################################################
    - name: Ensure application namespace exists
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ k8s_namespace }}"

    - name: Get wildcard certificate from default namespace
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig }}"
        api_version: v1
        kind: Secret
        namespace: default
        name: "{{ domain_name.replace('.', '-') }}-tls"
      register: wildcard_cert
      failed_when: wildcard_cert.resources | length == 0

    - name: Copy wildcard certificate to Qdrant namespace
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ tls_secret_name }}"
            namespace: "{{ k8s_namespace }}"
          type: kubernetes.io/tls
          data:
            tls.crt: "{{ wildcard_cert.resources[0].data['tls.crt'] }}"
            tls.key: "{{ wildcard_cert.resources[0].data['tls.key'] }}"

    ###########################################################################
    # Step 2: Setup Valkey (Redis-compatible)
    ###########################################################################
    - name: Deploy Ephemeral Valkey for session storage
      ansible.builtin.include_role:
        name: valkey/ephemeral_valkey
      vars:
        valkey_registry: "{{ harbor_registry }}/library"

    ###########################################################################
    # Step 3: Setup OAuth2 Proxy and Configure Keycloak CORS
    ###########################################################################
    - name: Get Keycloak admin token for CORS configuration
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/realms/master/protocol/openid-connect/token"
        method: POST
        body_format: form-urlencoded
        body:
          client_id: "admin-cli"
          username: "{{ keycloak_admin_user }}"
          password: "{{ keycloak_admin_password }}"
          grant_type: "password"
        validate_certs: false
        status_code: 200
      register: keycloak_token
      
    - name: Get current realm info
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        validate_certs: false
        status_code: 200
      register: realm_info
      
    - name: Configure Keycloak CORS for Qdrant Dashboard
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}"
        method: PUT
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
          Content-Type: "application/json"
        body_format: json
        body: "{{ realm_info.json | combine({
          'attributes': realm_info.json.attributes | default({}) | combine({
            '_browser_header.xRobotsTag': 'none',
            '_browser_header.xFrameOptions': 'ALLOW-FROM https://{{ qdrant_dashboard_host }}',
            '_browser_header.xXSSProtection': '1; mode=block',
            '_browser_header.xContentTypeOptions': 'nosniff',
            '_browser_header.contentSecurityPolicy': 'frame-src https://*.{{ domain_name }};',
            '_browser_header.accessControlAllowOrigin': 'https://{{ qdrant_dashboard_host }}',
            '_browser_header.accessControlAllowMethods': 'GET, POST, OPTIONS',
            '_browser_header.accessControlAllowHeaders': 'Origin, X-Requested-With, Content-Type, Accept, Authorization',
            '_browser_header.accessControlAllowCredentials': 'true'
          }, recursive=true)
        }, recursive=true) }}"
        validate_certs: false
        status_code: [200, 204]
      register: realm_cors_update

    - name: Get client details
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/clients?clientId=qdrant-dashboard"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
        validate_certs: false
        status_code: 200
      register: client_info
      
    - name: Update client with CORS settings
      ansible.builtin.uri:
        url: "{{ keycloak_url }}/admin/realms/{{ keycloak_realm }}/clients/{{ client_info.json[0].id }}"
        method: PUT
        headers:
          Authorization: "Bearer {{ keycloak_token.json.access_token }}"
          Content-Type: "application/json"
        body_format: json
        body: "{{ client_info.json[0] | combine({
          'webOrigins': ['*', 'https://{{ qdrant_dashboard_host }}', '+'],
          'attributes': client_info.json[0].attributes | default({}) | combine({
            'access.token.lifespan': '3600'
          })
        }, recursive=true) }}"
        validate_certs: false
        status_code: [200, 204]
      register: client_cors_update
      when: client_info.json | length > 0

    - name: Deploy OAuth2 Proxy with Keycloak authentication
      ansible.builtin.include_role:
        name: oauth2_proxy

    ###########################################################################
    # Step 4: Deploy Qdrant
    ###########################################################################
    - name: Add Qdrant Helm repository
      kubernetes.core.helm_repository:
        binary_path: "{{ helm_bin }}"
        name: qdrant
        repo_url: "https://qdrant.to/helm"
        state: present

    - name: Update Helm repos for Qdrant
      ansible.builtin.command: "{{ helm_bin }} repo update"
      changed_when: false

    - name: Deploy Qdrant (with CORS enabled)
      kubernetes.core.helm:
        binary_path: "{{ helm_bin }}"
        kubeconfig: "{{ kubeconfig }}"
        name: "qdrant"
        chart_ref: "qdrant/qdrant"
        release_namespace: "{{ k8s_namespace }}"
        create_namespace: false
        reset_values: true
        force: true
        update_repo_cache: true
        values:
          persistence:
            enabled: true
            storageClass: ""
            accessModes:
              - ReadWriteOnce
            size: 150Gi
          replicaCount: 1
          resources:
            requests:
              cpu: "2"
              memory: "4Gi"
            limits:
              cpu: "4"
              memory: "8Gi"
          service:
            grpc:
              enabled: true
              port: 6334
          cors:
            enabled: true
            allowedOrigins:
              - "https://{{ qdrant_dashboard_host }}"

    ###########################################################################
    # Step 5: Create Qdrant HTTP Ingress (secured via /oauth2/auth)
    ###########################################################################
    - name: Create or update Qdrant HTTP Dashboard Ingress
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: "qdrant-http-ingress"
            namespace: "{{ k8s_namespace }}"
            annotations:
              nginx.ingress.kubernetes.io/proxy-body-size: "0"
              nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
              nginx.ingress.kubernetes.io/auth-url: "https://$host/oauth2/auth"
              nginx.ingress.kubernetes.io/auth-signin: "https://$host/oauth2/start?rd=$escaped_request_uri"
          spec:
            ingressClassName: "{{ primary_ingress_class }}"
            tls:
              - hosts:
                  - "{{ qdrant_dashboard_host }}"
                secretName: "{{ tls_secret_name }}"
            rules:
              - host: "{{ qdrant_dashboard_host }}"
                http:
                  paths:
                    - path: "/"
                      pathType: Prefix
                      backend:
                        service:
                          name: "qdrant"
                          port:
                            number: 6333

    ###########################################################################
    # Step 6: Create a root-redirect Ingress (redirect "/" to "/dashboard")
    ###########################################################################
    - name: Create Qdrant root redirect Ingress
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: "qdrant-root-redirect"
            namespace: "{{ k8s_namespace }}"
            annotations:
              nginx.ingress.kubernetes.io/permanent-redirect: "https://{{ qdrant_dashboard_host }}/dashboard"
              nginx.ingress.kubernetes.io/permanent-redirect-code: "301"
          spec:
            ingressClassName: "{{ primary_ingress_class }}"
            rules:
              - host: "{{ qdrant_dashboard_host }}"
                http:
                  paths:
                    - path: "/"
                      pathType: Exact
                      backend:
                        service:
                          # Dummy backend; the redirect annotation takes precedence
                          name: "qdrant"
                          port:
                            number: 80
                            
    ###########################################################################
    # Step 7: Create Qdrant API Ingress (without authentication)
    ###########################################################################
    - name: Create or update Qdrant API Ingress
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig }}"
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: "qdrant-api-ingress"
            namespace: "{{ k8s_namespace }}"
            annotations:
              nginx.ingress.kubernetes.io/proxy-body-size: "0"
              nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
          spec:
            ingressClassName: "{{ primary_ingress_class }}"
            tls:
              - hosts:
                  - "{{ qdrant_hostname }}"
                secretName: "{{ tls_secret_name }}"
            rules:
              - host: "{{ qdrant_hostname }}"
                http:
                  paths:
                    - path: "/"
                      pathType: Prefix
                      backend:
                        service:
                          name: "qdrant"
                          port:
                            number: 6333

    ###########################################################################
    # Step 8: Debug task to check resources
    ###########################################################################
    - name: List all ingresses in namespace
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig }}"
        kind: Ingress
        namespace: "{{ k8s_namespace }}"
      register: ingresses

    - name: Debug ingresses
      ansible.builtin.debug:
        msg: "Ingresses in namespace: {{ ingresses.resources | map(attribute='metadata.name') | list }}"
        
    ###########################################################################
    # Step 9: Test Qdrant API endpoint
    ###########################################################################
    - name: Wait for Qdrant API to be ready (60 seconds timeout)
      ansible.builtin.uri:
        url: "https://{{ qdrant_hostname }}/collections"
        method: GET
        validate_certs: false
        headers:
          Content-Type: "application/json"
        status_code: 200
      register: qdrant_api_ready
      until: qdrant_api_ready.status == 200
      retries: 12  # 12 retries x 5s delay = 60s total waiting time
      delay: 5
      
    - name: Test Qdrant API endpoint (collection creation)
      ansible.builtin.uri:
        url: "https://{{ qdrant_hostname }}/collections/test_collection"
        method: PUT
        validate_certs: false
        headers:
          Content-Type: "application/json"
        body_format: json
        body:
          vectors:
            size: 4
            distance: "Cosine"
        status_code: [200, 201, 409]  # 409 if collection already exists
      
    - name: Display test results
      ansible.builtin.debug:
        msg: 
          - "Qdrant setup complete and API test successful!"
          - "API endpoint: https://{{ qdrant_hostname }}"
          - "Dashboard URL: https://{{ qdrant_dashboard_host }}"
        verbosity: 0